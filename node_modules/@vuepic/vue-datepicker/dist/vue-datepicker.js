import { openBlock as p, createElementBlock as I, createElementVNode as ae, reactive as $t, computed as L, unref as M, ref as H, watch as dt, toRef as Rt, onMounted as Ge, nextTick as ot, defineComponent as Xe, renderSlot as G, createCommentVNode as A, normalizeClass as ge, withKeys as ie, createBlock as me, withModifiers as He, normalizeStyle as ut, normalizeProps as Be, mergeProps as Ce, Fragment as ye, createTextVNode as tt, toDisplayString as Ye, renderList as Ne, createVNode as kt, Transition as Mt, withCtx as ce, onBeforeUpdate as oa, onUnmounted as hn, withDirectives as Ft, vShow as Ut, createSlots as Ue, guardReactiveProps as qe, resolveDynamicComponent as xn, useSlots as pn, getCurrentScope as sa, onScopeDispose as ua, isRef as Tn, Teleport as ia } from "vue";
import { isBefore as Ot, isEqual as yt, isAfter as It, set as _e, setHours as zn, setMinutes as jn, setSeconds as Kn, setMilliseconds as kn, getHours as lt, getMinutes as rt, getSeconds as Dt, parse as dn, isValid as Wt, isDate as da, format as Ct, getMonth as he, getDay as ca, getYear as ke, parseISO as fa, startOfWeek as An, endOfWeek as va, setMonth as Ht, setYear as it, addDays as gt, add as Gn, addMonths as ht, subMonths as Nt, getWeek as ma, getISOWeek as ya, differenceInCalendarDays as ga, eachDayOfInterval as Sn, addYears as ha, subYears as pa, sub as ka } from "date-fns";
function jt() {
  return p(), I(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      ae("path", {
        d: "M29.333 8c0-2.208-1.792-4-4-4h-18.667c-2.208 0-4 1.792-4 4v18.667c0 2.208 1.792 4 4 4h18.667c2.208 0 4-1.792 4-4v-18.667zM26.667 8v18.667c0 0.736-0.597 1.333-1.333 1.333 0 0-18.667 0-18.667 0-0.736 0-1.333-0.597-1.333-1.333 0 0 0-18.667 0-18.667 0-0.736 0.597-1.333 1.333-1.333 0 0 18.667 0 18.667 0 0.736 0 1.333 0.597 1.333 1.333z"
      }),
      ae("path", {
        d: "M20 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      }),
      ae("path", {
        d: "M9.333 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      }),
      ae("path", {
        d: "M4 14.667h24c0.736 0 1.333-0.597 1.333-1.333s-0.597-1.333-1.333-1.333h-24c-0.736 0-1.333 0.597-1.333 1.333s0.597 1.333 1.333 1.333z"
      })
    ]
  );
}
function wa() {
  return p(), I(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      ae("path", {
        d: "M23.057 7.057l-16 16c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l16-16c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0z"
      }),
      ae("path", {
        d: "M7.057 8.943l16 16c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885l-16-16c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
      })
    ]
  );
}
function Pn() {
  return p(), I(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      ae("path", {
        d: "M20.943 23.057l-7.057-7.057c0 0 7.057-7.057 7.057-7.057 0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-8 8c-0.521 0.521-0.521 1.365 0 1.885l8 8c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
      })
    ]
  );
}
function Cn() {
  return p(), I(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      ae("path", {
        d: "M12.943 24.943l8-8c0.521-0.521 0.521-1.365 0-1.885l-8-8c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885l7.057 7.057c0 0-7.057 7.057-7.057 7.057-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0z"
      })
    ]
  );
}
function Zn() {
  return p(), I(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      ae("path", {
        d: "M16 1.333c-8.095 0-14.667 6.572-14.667 14.667s6.572 14.667 14.667 14.667c8.095 0 14.667-6.572 14.667-14.667s-6.572-14.667-14.667-14.667zM16 4c6.623 0 12 5.377 12 12s-5.377 12-12 12c-6.623 0-12-5.377-12-12s5.377-12 12-12z"
      }),
      ae("path", {
        d: "M14.667 8v8c0 0.505 0.285 0.967 0.737 1.193l5.333 2.667c0.658 0.329 1.46 0.062 1.789-0.596s0.062-1.46-0.596-1.789l-4.596-2.298c0 0 0-7.176 0-7.176 0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      })
    ]
  );
}
function qn() {
  return p(), I(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      ae("path", {
        d: "M24.943 19.057l-8-8c-0.521-0.521-1.365-0.521-1.885 0l-8 8c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l7.057-7.057c0 0 7.057 7.057 7.057 7.057 0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
      })
    ]
  );
}
function Xn() {
  return p(), I(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      ae("path", {
        d: "M7.057 12.943l8 8c0.521 0.521 1.365 0.521 1.885 0l8-8c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-7.057 7.057c0 0-7.057-7.057-7.057-7.057-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
      })
    ]
  );
}
const Nn = (e, n, a, t, s) => {
  const m = dn(e, n.slice(0, e.length), /* @__PURE__ */ new Date());
  return Wt(m) && da(m) ? t || s ? m : _e(m, {
    hours: +a.hours,
    minutes: +(a == null ? void 0 : a.minutes),
    seconds: +(a == null ? void 0 : a.seconds),
    milliseconds: 0
  }) : null;
}, ba = (e, n, a, t, s) => {
  const m = Array.isArray(a) ? a[0] : a;
  if (typeof n == "string")
    return Nn(e, n, m, t, s);
  if (Array.isArray(n)) {
    let g = null;
    for (const C of n)
      if (g = Nn(e, C, m, t, s), g)
        break;
    return g;
  }
  return typeof n == "function" ? n(e) : null;
}, T = (e) => e ? new Date(e) : /* @__PURE__ */ new Date(), Da = (e, n, a) => {
  if (n) {
    const s = (e.getMonth() + 1).toString().padStart(2, "0"), m = e.getDate().toString().padStart(2, "0"), g = e.getHours().toString().padStart(2, "0"), C = e.getMinutes().toString().padStart(2, "0"), E = a ? e.getSeconds().toString().padStart(2, "0") : "00";
    return `${e.getFullYear()}-${s}-${m}T${g}:${C}:${E}.000Z`;
  }
  const t = Date.UTC(
    e.getUTCFullYear(),
    e.getUTCMonth(),
    e.getUTCDate(),
    e.getUTCHours(),
    e.getUTCMinutes(),
    e.getUTCSeconds()
  );
  return new Date(t).toISOString();
}, Ke = (e) => {
  let n = T(JSON.parse(JSON.stringify(e)));
  return n = zn(n, 0), n = jn(n, 0), n = Kn(n, 0), n = kn(n, 0), n;
}, je = (e, n, a, t) => {
  let s = e ? T(e) : T();
  return (n || n === 0) && (s = zn(s, +n)), (a || a === 0) && (s = jn(s, +a)), (t || t === 0) && (s = Kn(s, +t)), kn(s, 0);
}, Ve = (e, n) => !e || !n ? !1 : Ot(Ke(e), Ke(n)), pe = (e, n) => !e || !n ? !1 : yt(Ke(e), Ke(n)), Fe = (e, n) => !e || !n ? !1 : It(Ke(e), Ke(n)), Jn = (e, n, a) => e && e[0] && e[1] ? Fe(a, e[0]) && Ve(a, e[1]) : e && e[0] && n ? Fe(a, e[0]) && Ve(a, n) || Ve(a, e[0]) && Fe(a, n) : !1, St = (e) => {
  const n = _e(new Date(e), { date: 1 });
  return Ke(n);
}, Jt = (e, n, a) => n && (a || a === 0) ? Object.fromEntries(
  ["hours", "minutes", "seconds"].map((t) => t === n ? [t, a] : [t, isNaN(+e[t]) ? void 0 : +e[t]])
) : {
  hours: isNaN(+e.hours) ? void 0 : +e.hours,
  minutes: isNaN(+e.minutes) ? void 0 : +e.minutes,
  seconds: isNaN(+e.seconds) ? void 0 : +e.seconds
}, Et = (e) => ({
  hours: lt(e),
  minutes: rt(e),
  seconds: Dt(e)
}), Pt = $t({
  menuFocused: !1,
  shiftKeyInMenu: !1
}), Qn = () => {
  const e = (t) => {
    Pt.menuFocused = t;
  }, n = (t) => {
    Pt.shiftKeyInMenu !== t && (Pt.shiftKeyInMenu = t);
  };
  return {
    control: L(() => ({ shiftKeyInMenu: Pt.shiftKeyInMenu, menuFocused: Pt.menuFocused })),
    setMenuFocused: e,
    setShiftKey: n
  };
};
function wn(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var ea = { exports: {} };
(function(e) {
  function n(a) {
    return a && a.__esModule ? a : {
      default: a
    };
  }
  e.exports = n, e.exports.__esModule = !0, e.exports.default = e.exports;
})(ea);
var $a = ea.exports, cn = { exports: {} };
(function(e, n) {
  Object.defineProperty(n, "__esModule", {
    value: !0
  }), n.default = a;
  function a(t) {
    if (t === null || t === !0 || t === !1)
      return NaN;
    var s = Number(t);
    return isNaN(s) ? s : s < 0 ? Math.ceil(s) : Math.floor(s);
  }
  e.exports = n.default;
})(cn, cn.exports);
var Ma = cn.exports;
const Ta = /* @__PURE__ */ wn(Ma);
var fn = { exports: {} };
(function(e, n) {
  Object.defineProperty(n, "__esModule", {
    value: !0
  }), n.default = a;
  function a(t) {
    var s = new Date(Date.UTC(t.getFullYear(), t.getMonth(), t.getDate(), t.getHours(), t.getMinutes(), t.getSeconds(), t.getMilliseconds()));
    return s.setUTCFullYear(t.getFullYear()), t.getTime() - s.getTime();
  }
  e.exports = n.default;
})(fn, fn.exports);
var Aa = fn.exports;
const _n = /* @__PURE__ */ wn(Aa);
function Sa(e, n) {
  var a = _a(n);
  return a.formatToParts ? Ca(a, e) : Na(a, e);
}
var Pa = {
  year: 0,
  month: 1,
  day: 2,
  hour: 3,
  minute: 4,
  second: 5
};
function Ca(e, n) {
  try {
    for (var a = e.formatToParts(n), t = [], s = 0; s < a.length; s++) {
      var m = Pa[a[s].type];
      m >= 0 && (t[m] = parseInt(a[s].value, 10));
    }
    return t;
  } catch (g) {
    if (g instanceof RangeError)
      return [NaN];
    throw g;
  }
}
function Na(e, n) {
  var a = e.format(n).replace(/\u200E/g, ""), t = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(a);
  return [t[3], t[1], t[2], t[4], t[5], t[6]];
}
var Qt = {};
function _a(e) {
  if (!Qt[e]) {
    var n = new Intl.DateTimeFormat("en-US", {
      hour12: !1,
      timeZone: "America/New_York",
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    }).format(/* @__PURE__ */ new Date("2014-06-25T04:00:00.123Z")), a = n === "06/25/2014, 00:00:00" || n === "‎06‎/‎25‎/‎2014‎ ‎00‎:‎00‎:‎00";
    Qt[e] = a ? new Intl.DateTimeFormat("en-US", {
      hour12: !1,
      timeZone: e,
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    }) : new Intl.DateTimeFormat("en-US", {
      hourCycle: "h23",
      timeZone: e,
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    });
  }
  return Qt[e];
}
function bn(e, n, a, t, s, m, g) {
  var C = /* @__PURE__ */ new Date(0);
  return C.setUTCFullYear(e, n, a), C.setUTCHours(t, s, m, g), C;
}
var Rn = 36e5, Ra = 6e4, en = {
  timezone: /([Z+-].*)$/,
  timezoneZ: /^(Z)$/,
  timezoneHH: /^([+-]\d{2})$/,
  timezoneHHMM: /^([+-]\d{2}):?(\d{2})$/
};
function Dn(e, n, a) {
  var t, s;
  if (!e || (t = en.timezoneZ.exec(e), t))
    return 0;
  var m;
  if (t = en.timezoneHH.exec(e), t)
    return m = parseInt(t[1], 10), On(m) ? -(m * Rn) : NaN;
  if (t = en.timezoneHHMM.exec(e), t) {
    m = parseInt(t[1], 10);
    var g = parseInt(t[2], 10);
    return On(m, g) ? (s = Math.abs(m) * Rn + g * Ra, m > 0 ? -s : s) : NaN;
  }
  if (Ba(e)) {
    n = new Date(n || Date.now());
    var C = a ? n : Oa(n), E = vn(C, e), S = a ? E : Ia(n, E, e);
    return -S;
  }
  return NaN;
}
function Oa(e) {
  return bn(
    e.getFullYear(),
    e.getMonth(),
    e.getDate(),
    e.getHours(),
    e.getMinutes(),
    e.getSeconds(),
    e.getMilliseconds()
  );
}
function vn(e, n) {
  var a = Sa(e, n), t = bn(
    a[0],
    a[1] - 1,
    a[2],
    a[3] % 24,
    a[4],
    a[5],
    0
  ).getTime(), s = e.getTime(), m = s % 1e3;
  return s -= m >= 0 ? m : 1e3 + m, t - s;
}
function Ia(e, n, a) {
  var t = e.getTime(), s = t - n, m = vn(new Date(s), a);
  if (n === m)
    return n;
  s -= m - n;
  var g = vn(new Date(s), a);
  return m === g ? m : Math.max(m, g);
}
function On(e, n) {
  return -23 <= e && e <= 23 && (n == null || 0 <= n && n <= 59);
}
var In = {};
function Ba(e) {
  if (In[e])
    return !0;
  try {
    return new Intl.DateTimeFormat(void 0, { timeZone: e }), In[e] = !0, !0;
  } catch {
    return !1;
  }
}
var Ya = /(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/;
const ta = Ya;
var tn = 36e5, Bn = 6e4, Va = 2, Le = {
  dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,
  datePattern: /^([0-9W+-]+)(.*)/,
  plainTime: /:/,
  // year tokens
  YY: /^(\d{2})$/,
  YYY: [
    /^([+-]\d{2})$/,
    // 0 additional digits
    /^([+-]\d{3})$/,
    // 1 additional digit
    /^([+-]\d{4})$/
    // 2 additional digits
  ],
  YYYY: /^(\d{4})/,
  YYYYY: [
    /^([+-]\d{4})/,
    // 0 additional digits
    /^([+-]\d{5})/,
    // 1 additional digit
    /^([+-]\d{6})/
    // 2 additional digits
  ],
  // date tokens
  MM: /^-(\d{2})$/,
  DDD: /^-?(\d{3})$/,
  MMDD: /^-?(\d{2})-?(\d{2})$/,
  Www: /^-?W(\d{2})$/,
  WwwD: /^-?W(\d{2})-?(\d{1})$/,
  HH: /^(\d{2}([.,]\d*)?)$/,
  HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
  HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
  // time zone tokens (to identify the presence of a tz)
  timeZone: ta
};
function mn(e, n) {
  if (arguments.length < 1)
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  if (e === null)
    return /* @__PURE__ */ new Date(NaN);
  var a = n || {}, t = a.additionalDigits == null ? Va : Ta(a.additionalDigits);
  if (t !== 2 && t !== 1 && t !== 0)
    throw new RangeError("additionalDigits must be 0, 1 or 2");
  if (e instanceof Date || typeof e == "object" && Object.prototype.toString.call(e) === "[object Date]")
    return new Date(e.getTime());
  if (typeof e == "number" || Object.prototype.toString.call(e) === "[object Number]")
    return new Date(e);
  if (!(typeof e == "string" || Object.prototype.toString.call(e) === "[object String]"))
    return /* @__PURE__ */ new Date(NaN);
  var s = Ea(e), m = La(s.date, t), g = m.year, C = m.restDateString, E = Fa(C, g);
  if (isNaN(E))
    return /* @__PURE__ */ new Date(NaN);
  if (E) {
    var S = E.getTime(), F = 0, P;
    if (s.time && (F = Ua(s.time), isNaN(F)))
      return /* @__PURE__ */ new Date(NaN);
    if (s.timeZone || a.timeZone) {
      if (P = Dn(s.timeZone || a.timeZone, new Date(S + F)), isNaN(P))
        return /* @__PURE__ */ new Date(NaN);
    } else
      P = _n(new Date(S + F)), P = _n(new Date(S + F + P));
    return new Date(S + F + P);
  } else
    return /* @__PURE__ */ new Date(NaN);
}
function Ea(e) {
  var n = {}, a = Le.dateTimePattern.exec(e), t;
  if (a ? (n.date = a[1], t = a[3]) : (a = Le.datePattern.exec(e), a ? (n.date = a[1], t = a[2]) : (n.date = null, t = e)), t) {
    var s = Le.timeZone.exec(t);
    s ? (n.time = t.replace(s[1], ""), n.timeZone = s[1].trim()) : n.time = t;
  }
  return n;
}
function La(e, n) {
  var a = Le.YYY[n], t = Le.YYYYY[n], s;
  if (s = Le.YYYY.exec(e) || t.exec(e), s) {
    var m = s[1];
    return {
      year: parseInt(m, 10),
      restDateString: e.slice(m.length)
    };
  }
  if (s = Le.YY.exec(e) || a.exec(e), s) {
    var g = s[1];
    return {
      year: parseInt(g, 10) * 100,
      restDateString: e.slice(g.length)
    };
  }
  return {
    year: null
  };
}
function Fa(e, n) {
  if (n === null)
    return null;
  var a, t, s, m;
  if (e.length === 0)
    return t = /* @__PURE__ */ new Date(0), t.setUTCFullYear(n), t;
  if (a = Le.MM.exec(e), a)
    return t = /* @__PURE__ */ new Date(0), s = parseInt(a[1], 10) - 1, Vn(n, s) ? (t.setUTCFullYear(n, s), t) : /* @__PURE__ */ new Date(NaN);
  if (a = Le.DDD.exec(e), a) {
    t = /* @__PURE__ */ new Date(0);
    var g = parseInt(a[1], 10);
    return xa(n, g) ? (t.setUTCFullYear(n, 0, g), t) : /* @__PURE__ */ new Date(NaN);
  }
  if (a = Le.MMDD.exec(e), a) {
    t = /* @__PURE__ */ new Date(0), s = parseInt(a[1], 10) - 1;
    var C = parseInt(a[2], 10);
    return Vn(n, s, C) ? (t.setUTCFullYear(n, s, C), t) : /* @__PURE__ */ new Date(NaN);
  }
  if (a = Le.Www.exec(e), a)
    return m = parseInt(a[1], 10) - 1, En(n, m) ? Yn(n, m) : /* @__PURE__ */ new Date(NaN);
  if (a = Le.WwwD.exec(e), a) {
    m = parseInt(a[1], 10) - 1;
    var E = parseInt(a[2], 10) - 1;
    return En(n, m, E) ? Yn(n, m, E) : /* @__PURE__ */ new Date(NaN);
  }
  return null;
}
function Ua(e) {
  var n, a, t;
  if (n = Le.HH.exec(e), n)
    return a = parseFloat(n[1].replace(",", ".")), nn(a) ? a % 24 * tn : NaN;
  if (n = Le.HHMM.exec(e), n)
    return a = parseInt(n[1], 10), t = parseFloat(n[2].replace(",", ".")), nn(a, t) ? a % 24 * tn + t * Bn : NaN;
  if (n = Le.HHMMSS.exec(e), n) {
    a = parseInt(n[1], 10), t = parseInt(n[2], 10);
    var s = parseFloat(n[3].replace(",", "."));
    return nn(a, t, s) ? a % 24 * tn + t * Bn + s * 1e3 : NaN;
  }
  return null;
}
function Yn(e, n, a) {
  n = n || 0, a = a || 0;
  var t = /* @__PURE__ */ new Date(0);
  t.setUTCFullYear(e, 0, 4);
  var s = t.getUTCDay() || 7, m = n * 7 + a + 1 - s;
  return t.setUTCDate(t.getUTCDate() + m), t;
}
var Wa = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], Ha = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function na(e) {
  return e % 400 === 0 || e % 4 === 0 && e % 100 !== 0;
}
function Vn(e, n, a) {
  if (n < 0 || n > 11)
    return !1;
  if (a != null) {
    if (a < 1)
      return !1;
    var t = na(e);
    if (t && a > Ha[n] || !t && a > Wa[n])
      return !1;
  }
  return !0;
}
function xa(e, n) {
  if (n < 1)
    return !1;
  var a = na(e);
  return !(a && n > 366 || !a && n > 365);
}
function En(e, n, a) {
  return !(n < 0 || n > 52 || a != null && (a < 0 || a > 6));
}
function nn(e, n, a) {
  return !(e != null && (e < 0 || e >= 25) || n != null && (n < 0 || n >= 60) || a != null && (a < 0 || a >= 60));
}
var yn = { exports: {} }, gn = { exports: {} };
(function(e, n) {
  Object.defineProperty(n, "__esModule", {
    value: !0
  }), n.default = a;
  function a(t, s) {
    if (t == null)
      throw new TypeError("assign requires that input parameter not be null or undefined");
    for (var m in s)
      Object.prototype.hasOwnProperty.call(s, m) && (t[m] = s[m]);
    return t;
  }
  e.exports = n.default;
})(gn, gn.exports);
var za = gn.exports;
(function(e, n) {
  var a = $a.default;
  Object.defineProperty(n, "__esModule", {
    value: !0
  }), n.default = s;
  var t = a(za);
  function s(m) {
    return (0, t.default)({}, m);
  }
  e.exports = n.default;
})(yn, yn.exports);
var ja = yn.exports;
const Ka = /* @__PURE__ */ wn(ja);
function Ga(e, n, a) {
  var t = mn(e, a), s = Dn(n, t, !0), m = new Date(t.getTime() - s), g = /* @__PURE__ */ new Date(0);
  return g.setFullYear(m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate()), g.setHours(m.getUTCHours(), m.getUTCMinutes(), m.getUTCSeconds(), m.getUTCMilliseconds()), g;
}
function Za(e, n, a) {
  if (typeof e == "string" && !e.match(ta)) {
    var t = Ka(a);
    return t.timeZone = n, mn(e, t);
  }
  var s = mn(e, a), m = bn(
    s.getFullYear(),
    s.getMonth(),
    s.getDate(),
    s.getHours(),
    s.getMinutes(),
    s.getSeconds(),
    s.getMilliseconds()
  ).getTime(), g = Dn(n, new Date(m));
  return new Date(m + g);
}
const qa = (e, n = 3) => {
  const a = [];
  for (let t = 0; t < e.length; t += n)
    a.push([e[t], e[t + 1], e[t + 2]]);
  return a;
}, Xa = (e, n) => {
  const a = [1, 2, 3, 4, 5, 6, 7].map((m) => new Intl.DateTimeFormat(e, { weekday: "short", timeZone: "UTC" }).format(/* @__PURE__ */ new Date(`2017-01-0${m}T00:00:00+00:00`)).slice(0, 2)), t = a.slice(0, n), s = a.slice(n + 1, a.length);
  return [a[n]].concat(...s).concat(...t);
}, Ja = (e, n) => {
  const a = [];
  for (let t = +e[0]; t <= +e[1]; t++)
    a.push({ value: +t, text: `${t}` });
  return n ? a.reverse() : a;
}, Qa = (e, n) => {
  const a = new Intl.DateTimeFormat(e, { month: n, timeZone: "UTC" });
  return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map((s) => {
    const m = s < 10 ? `0${s}` : s;
    return /* @__PURE__ */ new Date(`2017-${m}-01T00:00:00+00:00`);
  }).map((s, m) => {
    const g = a.format(s);
    return {
      text: g.charAt(0).toUpperCase() + g.substring(1),
      value: m
    };
  });
}, el = (e) => [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11][e], Te = (e) => {
  const n = M(e);
  return n != null && n.$el ? n == null ? void 0 : n.$el : n;
}, tl = (e) => Object.assign({ type: "dot" }, e), aa = (e) => Array.isArray(e) ? !!e[0] && !!e[1] : !1, zt = {
  prop: (e) => `"${e}" prop must be enabled!`,
  dateArr: (e) => `You need to use array as "model-value" binding in order to support "${e}"`
}, Pe = (e) => e, Ln = (e) => e === 0 ? e : !e || isNaN(+e) ? null : +e, nl = (e) => {
  if (e)
    return [...e.querySelectorAll("input, button, select, textarea, a[href]")][0];
}, Fn = (e) => Object.assign(
  {
    menuAppear: "",
    open: "dp-slide-down",
    close: "dp-slide-up",
    next: "calendar-next",
    previous: "calendar-prev",
    vNext: "dp-slide-up",
    vPrevious: "dp-slide-down"
  },
  e
), al = (e) => Object.assign(
  {
    toggleOverlay: "Toggle overlay",
    menu: "Datepicker menu",
    input: "Datepicker input",
    calendarWrap: "Calendar wrapper",
    calendarDays: "Calendar days",
    openTimePicker: "Open time picker",
    closeTimePicker: "Close time Picker",
    incrementValue: (n) => `Increment ${n}`,
    decrementValue: (n) => `Decrement ${n}`,
    openTpOverlay: (n) => `Open ${n} overlay`,
    amPmButton: "Switch AM/PM mode",
    openYearsOverlay: "Open years overlay",
    openMonthsOverlay: "Open months overlay",
    nextMonth: "Next month",
    prevMonth: "Previous month",
    day: () => ""
  },
  e
), ll = (e) => e === null ? 0 : typeof e == "boolean" ? e ? 2 : 0 : +e >= 2 ? +e : 2, rl = (e, n, a) => e || (typeof a == "string" ? a : n), ol = (e) => typeof e == "boolean" ? e ? Fn({}) : !1 : Fn(e), sl = () => ({
  enterSubmit: !0,
  tabSubmit: !0,
  openMenu: !0,
  rangeSeparator: " - "
}), ul = (e) => Object.assign({ months: [], years: [], times: { hours: [], minutes: [], seconds: [] } }, e), il = (e) => Object.assign({ showSelect: !0, showCancel: !0, showNow: !1, showPreview: !0 }, e), xe = (e) => {
  const n = () => {
    if (e.partialRange)
      return null;
    throw new Error(zt.prop("partial-range"));
  }, a = L(() => ({
    ariaLabels: al(e.ariaLabels),
    textInputOptions: Object.assign(sl(), e.textInputOptions),
    multiCalendars: ll(e.multiCalendars),
    previewFormat: rl(e.previewFormat, e.format, m()),
    filters: ul(e.filters),
    transitions: ol(e.transitions),
    startTime: c(),
    actionRow: il(e.actionRow)
  })), t = (l) => {
    if (e.range)
      return l();
    throw new Error(zt.prop("range"));
  }, s = () => {
    const l = e.enableSeconds ? ":ss" : "";
    return e.is24 ? `HH:mm${l}` : `hh:mm${l} aa`;
  }, m = () => e.format ? e.format : e.monthPicker ? "MM/yyyy" : e.timePicker ? s() : e.weekPicker ? "MM/dd/yyyy" : e.yearPicker ? "yyyy" : e.enableTimePicker ? `MM/dd/yyyy, ${s()}` : "MM/dd/yyyy", g = (l, v) => {
    if (typeof e.format == "function")
      return e.format(l);
    const R = v || m(), i = e.formatLocale ? { locale: e.formatLocale } : void 0;
    return Array.isArray(l) ? `${Ct(l[0], R, i)}${e.modelAuto && !l[1] ? "" : a.value.textInputOptions.rangeSeparator || "-"}${l[1] ? Ct(l[1], R, i) : ""}` : Ct(l, R, i);
  }, C = (l) => e.timezone ? Ga(l, e.timezone) : l, E = (l) => e.timezone ? Za(l, e.timezone) : l, S = L(() => (l) => {
    var v;
    return (v = e.hideNavigation) == null ? void 0 : v.includes(l);
  }), F = (l) => {
    var ee, We;
    const v = e.maxDate ? Fe(C(l), C(T(e.maxDate))) : !1, R = e.minDate ? Ve(C(l), C(T(e.minDate))) : !1, i = B(
      l,
      (ee = e.arrMapValues) != null && ee.disabledDates ? e.arrMapValues.disabledDates : e.disabledDates
    ), Y = a.value.filters.months.map((Ie) => +Ie).includes(he(l)), le = e.disabledWeekDays.length ? e.disabledWeekDays.some((Ie) => +Ie === ca(l)) : !1, Ae = B(
      l,
      (We = e.arrMapValues) != null && We.allowedDates ? e.arrMapValues.allowedDates : e.allowedDates
    ), Se = ke(l), be = Se < +e.yearRange[0] || Se > +e.yearRange[1];
    return !(v || R || i || Y || be || le || Ae);
  }, P = (l) => {
    const v = {
      hours: lt(T()),
      minutes: rt(T()),
      seconds: e.enableSeconds ? Dt(T()) : 0
    };
    return Object.assign(v, l);
  }, c = () => e.range ? e.startTime && Array.isArray(e.startTime) ? [P(e.startTime[0]), P(e.startTime[1])] : null : e.startTime && !Array.isArray(e.startTime) ? P(e.startTime) : null, k = (l) => !F(l), Q = (l) => Array.isArray(l) ? Wt(l[0]) && (l[1] ? Wt(l[1]) : !0) : l ? Wt(l) : !1, j = (l) => l instanceof Date ? l : fa(l), x = (l) => {
    const v = An(C(l), { weekStartsOn: +e.weekStart }), R = va(C(l), { weekStartsOn: +e.weekStart });
    return [v, R];
  }, B = (l, v) => l ? v instanceof Map ? !!v.get(z(l)) : Array.isArray(v) ? v.some((R) => pe(C(T(R)), C(l))) : v(T(JSON.parse(JSON.stringify(l)))) : !0, U = (l, v, R) => {
    let i = l ? T(l) : T();
    return (v || v === 0) && (i = Ht(i, v)), R && (i = it(i, R)), i;
  }, O = (l) => _e(T(), Et(l)), q = (l) => _e(T(), {
    hours: +l.hours || 0,
    minutes: +l.minutes || 0,
    seconds: +l.seconds || 0
  }), K = (l, v, R, i) => {
    if (!l)
      return !0;
    if (i) {
      const r = R === "max" ? Ot(l, v) : It(l, v), Y = { seconds: 0, milliseconds: 0 };
      return r || yt(_e(l, Y), _e(v, Y));
    }
    return R === "max" ? l.getTime() <= v.getTime() : l.getTime() >= v.getTime();
  }, ne = () => !e.enableTimePicker || e.monthPicker || e.yearPicker || e.ignoreTimeValidation, se = (l) => Array.isArray(l) ? [l[0] ? O(l[0]) : null, l[1] ? O(l[1]) : null] : O(l), de = (l) => {
    const v = e.maxTime ? q(e.maxTime) : T(e.maxDate);
    return Array.isArray(l) ? K(l[0], v, "max", !!e.maxDate) && K(l[1], v, "max", !!e.maxDate) : K(l, v, "max", !!e.maxDate);
  }, ue = (l, v) => {
    const R = e.minTime ? q(e.minTime) : T(e.minDate);
    return Array.isArray(l) ? K(l[0], R, "min", !!e.minDate) && K(l[1], R, "min", !!e.minDate) && v : K(l, R, "min", !!e.minDate) && v;
  }, ve = (l) => {
    let v = !0;
    if (!l || ne())
      return !0;
    const R = !e.minDate && !e.maxDate ? se(l) : l;
    if ((e.maxTime || e.maxDate) && (v = de(Pe(R))), (e.minTime || e.minDate) && (v = ue(Pe(R), v)), e.disabledTimes) {
      const i = Array.isArray(l) ? [Et(l[0]), l[1] ? Et(l[1]) : void 0] : Et(l);
      v = !e.disabledTimes(i);
    }
    return v;
  }, V = (l, v) => {
    const R = T(JSON.parse(JSON.stringify(l))), i = [];
    for (let r = 0; r < 7; r++) {
      const Y = gt(R, r), le = he(Y) !== v;
      i.push({
        text: e.hideOffsetDates && le ? "" : Y.getDate(),
        value: Y,
        current: !le,
        classData: {}
      });
    }
    return i;
  }, D = (l, v) => {
    const R = [], i = T(C(new Date(v, l))), r = T(C(new Date(v, l + 1, 0))), Y = e.weekStart, le = An(i, { weekStartsOn: Y }), Ae = (Se) => {
      const be = V(Se, l);
      if (R.push({ days: be }), !R[R.length - 1].days.some(
        (ee) => pe(Ke(ee.value), Ke(r))
      )) {
        const ee = gt(Se, 7);
        Ae(ee);
      }
    };
    if (Ae(le), e.sixWeeks && R.length < 6) {
      const Se = 6 - R.length, be = (i.getDay() + 7 - Y) % 7, We = 6 - (r.getDay() + 7 - Y) % 7, [Ie, Re] = (() => {
        switch (e.sixWeeks === !0 ? "append" : e.sixWeeks) {
          case "prepend":
            return [!0, !1];
          case "center":
            return [be == 0, !0];
          case "fair":
            return [be == 0 || We > be, !0];
          default:
          case "append":
            return [!1, !1];
        }
      })();
      for (let Ze = 1; Ze <= Se; Ze++)
        if (Re ? !!(Ze % 2) == Ie : Ie) {
          const Je = R[0].days[0], nt = V(gt(Je.value, -7), he(i));
          R.unshift({ days: nt });
        } else {
          const Je = R[R.length - 1], nt = Je.days[Je.days.length - 1], ze = V(gt(nt.value, 1), he(i));
          R.push({ days: ze });
        }
    }
    return R;
  }, d = (l, v, R) => [_e(T(l), { date: 1 }), _e(T(), { month: v, year: R, date: 1 })], N = (l, v) => Ve(...d(e.minDate, l, v)) || pe(...d(e.minDate, l, v)), _ = (l, v) => Fe(...d(e.maxDate, l, v)) || pe(...d(e.maxDate, l, v)), w = (l, v, R) => {
    let i = !1;
    return e.maxDate && R && _(l, v) && (i = !0), e.minDate && !R && N(l, v) && (i = !0), i;
  }, y = (l, v, R, i) => {
    let r = !1;
    return i ? e.minDate && e.maxDate ? r = w(l, v, R) : (e.minDate && N(l, v) || e.maxDate && _(l, v)) && (r = !0) : r = !0, r;
  }, z = (l) => {
    const v = Ke(C(T(l))).toISOString(), [R] = v.split("T");
    return R;
  }, f = (l) => new Map(l.map((v) => [z(v), !0])), u = (l) => Array.isArray(l);
  return {
    checkPartialRangeValue: n,
    checkRangeEnabled: t,
    getZonedDate: C,
    getZonedToUtc: E,
    formatDate: g,
    getDefaultPattern: m,
    validateDate: F,
    getDefaultStartTime: c,
    isDisabled: k,
    isValidDate: Q,
    sanitizeDate: j,
    getWeekFromDate: x,
    matchDate: B,
    setDateMonthOrYear: U,
    isValidTime: ve,
    getCalendarDays: D,
    validateMonthYearInRange: y,
    validateMaxDate: _,
    validateMinDate: N,
    assignDefaultTime: P,
    mapDatesArrToMap: (l) => {
      u(e.allowedDates) && (l.allowedDates = f(e.allowedDates)), u(e.highlight) && (l.highlightedDates = f(e.highlight)), u(e.disabledDates) && (l.disabledDates = f(e.disabledDates));
    },
    defaults: a,
    hideNavigationButtons: S
  };
}, we = $t({
  monthYear: [],
  calendar: [],
  time: [],
  actionRow: [],
  selectionGrid: [],
  timePicker: {
    0: [],
    1: []
  },
  monthPicker: []
}), an = H(null), Lt = H(!1), ln = H(!1), rn = H(!1), on = H(!1), Ee = H(0), Oe = H(0), ct = () => {
  const e = L(() => Lt.value ? [...we.selectionGrid, we.actionRow].filter((B) => B.length) : ln.value ? [
    ...we.timePicker[0],
    ...we.timePicker[1],
    on.value ? [] : [an.value],
    we.actionRow
  ].filter((B) => B.length) : rn.value ? [...we.monthPicker, we.actionRow] : [we.monthYear, ...we.calendar, we.time, we.actionRow].filter((B) => B.length)), n = (B) => {
    Ee.value = B ? Ee.value + 1 : Ee.value - 1;
    let U = null;
    e.value[Oe.value] && (U = e.value[Oe.value][Ee.value]), U || (Ee.value = B ? Ee.value - 1 : Ee.value + 1);
  }, a = (B) => {
    if (Oe.value === 0 && !B || Oe.value === e.value.length && B)
      return;
    Oe.value = B ? Oe.value + 1 : Oe.value - 1, e.value[Oe.value] ? e.value[Oe.value] && !e.value[Oe.value][Ee.value] && Ee.value !== 0 && (Ee.value = e.value[Oe.value].length - 1) : Oe.value = B ? Oe.value - 1 : Oe.value + 1;
  }, t = (B) => {
    let U = null;
    e.value[Oe.value] && (U = e.value[Oe.value][Ee.value]), U ? U.focus({ preventScroll: !Lt.value }) : Ee.value = B ? Ee.value - 1 : Ee.value + 1;
  }, s = () => {
    n(!0), t(!0);
  }, m = () => {
    n(!1), t(!1);
  }, g = () => {
    a(!1), t(!0);
  }, C = () => {
    a(!0), t(!0);
  }, E = (B, U) => {
    we[U] = B;
  }, S = (B, U) => {
    we[U] = B;
  }, F = () => {
    Ee.value = 0, Oe.value = 0;
  };
  return {
    buildMatrix: E,
    buildMultiLevelMatrix: S,
    setTimePickerBackRef: (B) => {
      an.value = B;
    },
    setSelectionGrid: (B) => {
      Lt.value = B, F(), B || (we.selectionGrid = []);
    },
    setTimePicker: (B, U = !1) => {
      ln.value = B, on.value = U, F(), B || (we.timePicker[0] = [], we.timePicker[1] = []);
    },
    setTimePickerElements: (B, U = 0) => {
      we.timePicker[U] = B;
    },
    arrowRight: s,
    arrowLeft: m,
    arrowUp: g,
    arrowDown: C,
    clearArrowNav: () => {
      we.monthYear = [], we.calendar = [], we.time = [], we.actionRow = [], we.selectionGrid = [], we.timePicker[0] = [], we.timePicker[1] = [], Lt.value = !1, ln.value = !1, on.value = !1, rn.value = !1, F(), an.value = null;
    },
    setMonthPicker: (B) => {
      rn.value = B, F();
    },
    refSets: we
    // exposed for testing
  };
}, Un = (e) => Array.isArray(e), mt = (e) => Array.isArray(e), Wn = (e) => Array.isArray(e) && e.length === 2, dl = (e, n, a, t, s) => {
  const {
    getDefaultStartTime: m,
    isDisabled: g,
    sanitizeDate: C,
    getWeekFromDate: E,
    setDateMonthOrYear: S,
    validateMonthYearInRange: F,
    defaults: P
  } = xe(e), c = L({
    get: () => e.internalModelValue,
    set: (o) => {
      !e.readonly && !e.disabled && n("update:internal-model-value", o);
    }
  }), k = H([]);
  dt(c, (o, b) => {
    e.range ? se() : yt(o, b) || se();
  });
  const Q = Rt(e, "multiCalendars");
  dt(Q, () => {
    ze(0);
  });
  const j = H([{ month: he(T()), year: ke(T()) }]), x = $t({
    hours: e.range ? [lt(T()), lt(T())] : lt(T()),
    minutes: e.range ? [rt(T()), rt(T())] : rt(T()),
    seconds: e.range ? [0, 0] : 0
  }), B = L(
    () => (o) => j.value[o] ? j.value[o].month : 0
  ), U = L(
    () => (o) => j.value[o] ? j.value[o].year : 0
  ), O = L(() => e.flow && e.flow.length && !e.partialFlow ? s.value === e.flow.length : !0), q = (o, b, X) => {
    var te, De;
    j.value[o] || (j.value[o] = { month: 0, year: 0 }), j.value[o].month = b === null ? (te = j.value[o]) == null ? void 0 : te.month : b, j.value[o].year = X === null ? (De = j.value[o]) == null ? void 0 : De.year : X;
  }, K = (o, b) => {
    x[o] = b;
  }, ne = () => {
    e.startDate && (q(0, he(T(e.startDate)), ke(T(e.startDate))), P.value.multiCalendars && ze(0));
  };
  Ge(() => {
    c.value || (ne(), P.value.startTime && y()), se(!0), e.focusStartDate && e.startDate && ne();
  });
  const se = (o = !1) => {
    if (c.value)
      return Array.isArray(c.value) ? (k.value = c.value, D(o)) : ue(c.value, o);
    if (e.timePicker)
      return d();
    if (e.monthPicker && !e.range)
      return N();
    if (e.yearPicker && !e.range)
      return _();
    if (P.value.multiCalendars && o && !e.startDate)
      return de(T(), o);
  }, de = (o, b = !1) => {
    if ((!P.value.multiCalendars || !e.multiStatic || b) && q(0, he(o), ke(o)), P.value.multiCalendars)
      for (let X = 1; X < P.value.multiCalendars; X++) {
        const te = _e(T(), { month: B.value(X - 1), year: U.value(X - 1) }), De = Gn(te, { months: 1 });
        j.value[X] = { month: he(De), year: ke(De) };
      }
  }, ue = (o, b) => {
    de(o), K("hours", lt(o)), K("minutes", rt(o)), K("seconds", Dt(o)), P.value.multiCalendars && b && f();
  }, ve = (o, b) => {
    o[1] && e.showLastInRange ? de(o[1], b) : de(o[0], b);
    const X = (te, De) => [
      te(o[0]),
      o[1] ? te(o[1]) : x[De][1]
    ];
    K("hours", X(lt, "hours")), K("minutes", X(rt, "minutes")), K("seconds", X(Dt, "seconds"));
  }, V = (o, b) => {
    if ((e.range || e.weekPicker) && !e.multiDates)
      return ve(o, b);
    if (e.multiDates) {
      const X = o[o.length - 1];
      return ue(X, b);
    }
  }, D = (o) => {
    const b = c.value;
    V(b, o), P.value.multiCalendars && e.multiCalendarsSolo && f();
  }, d = () => {
    if (y(), !e.range)
      c.value = je(T(), x.hours, x.minutes, w());
    else {
      const o = x.hours, b = x.minutes;
      c.value = [
        je(T(), o[0], b[0], w()),
        je(T(), o[1], b[1], w(!1))
      ];
    }
  }, N = () => {
    e.multiDates ? c.value = [S(T(), B.value(0), U.value(0))] : c.value = S(T(), B.value(0), U.value(0));
  }, _ = () => {
    c.value = T();
  }, w = (o = !0) => e.enableSeconds ? Array.isArray(x.seconds) ? o ? x.seconds[0] : x.seconds[1] : x.seconds : 0, y = () => {
    const o = m();
    if (o) {
      const b = Array.isArray(o), X = b ? [+o[0].hours, +o[1].hours] : +o.hours, te = b ? [+o[0].minutes, +o[1].minutes] : +o.minutes, De = b ? [+o[0].seconds, +o[1].seconds] : +o.seconds;
      K("hours", X), K("minutes", te), e.enableSeconds && K("seconds", De);
    }
  }, z = () => Array.isArray(c.value) && c.value.length ? c.value[c.value.length - 1] : null, f = () => {
    if (Array.isArray(c.value) && c.value.length === 2) {
      const o = T(
        T(c.value[1] ? c.value[1] : ht(c.value[0], 1))
      ), [b, X] = [he(c.value[0]), ke(c.value[0])], [te, De] = [he(c.value[1]), ke(c.value[1])];
      (b !== te || b === te && X !== De) && e.multiCalendarsSolo && q(1, he(o), ke(o));
    } else
      c.value && !Array.isArray(c.value) && q(0, he(c.value), ke(c.value));
  }, u = (o) => {
    const b = ht(o, 1);
    return { month: he(b), year: ke(b) };
  }, $ = (o) => {
    const b = he(T(o)), X = ke(T(o));
    if (q(0, b, X), P.value.multiCalendars > 0)
      for (let te = 1; te < P.value.multiCalendars; te++) {
        const De = u(
          _e(T(o), { year: B.value(te - 1), month: U.value(te - 1) })
        );
        q(te, De.month, De.year);
      }
  }, l = (o) => {
    if (c.value && Array.isArray(c.value))
      if (c.value.some((b) => pe(o, b))) {
        const b = c.value.filter((X) => !pe(X, o));
        c.value = b.length ? b : null;
      } else
        (e.multiDatesLimit && +e.multiDatesLimit > c.value.length || !e.multiDatesLimit) && c.value.push(o);
    else
      c.value = [o];
  }, v = (o, b) => {
    const X = Fe(o, b) ? b : o, te = Fe(b, o) ? b : o;
    return Sn({ start: X, end: te });
  }, R = (o, b = 0) => {
    if (Array.isArray(c.value) && c.value[b]) {
      const X = ga(o, c.value[b]), te = v(c.value[b], o), De = te.length === 1 ? 0 : te.filter((st) => g(st)).length, Qe = Math.abs(X) - De;
      if (e.minRange && e.maxRange)
        return Qe >= +e.minRange && Qe <= +e.maxRange;
      if (e.minRange)
        return Qe >= +e.minRange;
      if (e.maxRange)
        return Qe <= +e.maxRange;
    }
    return !0;
  }, i = (o) => Array.isArray(c.value) && c.value.length === 2 ? e.fixedStart && (Fe(o, c.value[0]) || pe(o, c.value[0])) ? [c.value[0], o] : e.fixedEnd && (Ve(o, c.value[1]) || pe(o, c.value[1])) ? [o, c.value[1]] : (n("invalid-fixed-range", o), c.value) : [], r = () => {
    e.autoApply && O.value && n("auto-apply", e.partialFlow);
  }, Y = () => {
    e.autoApply && n("select-date");
  }, le = (o) => !Sn({ start: o[0], end: o[1] }).some((X) => g(X)), Ae = (o) => (c.value = E(T(o.value)), r()), Se = (o) => {
    const b = je(T(o.value), x.hours, x.minutes, w());
    e.multiDates ? l(b) : c.value = b, a(), r();
  }, be = () => {
    k.value = c.value ? c.value.slice() : [], k.value.length === 2 && !(e.fixedStart || e.fixedEnd) && (k.value = []);
  }, ee = (o, b) => {
    const X = [T(o.value), gt(T(o.value), +e.autoRange)];
    le(X) && (b && $(o.value), k.value = X);
  }, We = (o) => {
    Ie(o.value) || !R(o.value, e.fixedStart ? 0 : 1) || (k.value = i(T(o.value)));
  }, Ie = (o) => e.noDisabledRange ? v(k.value[0], o).some((X) => g(X)) : !1, Re = (o, b) => {
    if (be(), e.autoRange)
      return ee(o, b);
    if (e.fixedStart || e.fixedEnd)
      return We(o);
    k.value[0] ? R(T(o.value)) && !Ie(o.value) && (Ve(T(o.value), T(k.value[0])) ? (k.value.unshift(T(o.value)), n("range-end", k.value[0])) : (k.value[1] = T(o.value), n("range-end", k.value[1]))) : (k.value[0] = T(o.value), n("range-start", k.value[0]));
  }, Ze = (o) => {
    k.value[o] = je(
      k.value[o],
      x.hours[o],
      x.minutes[o],
      w(o !== 1)
    );
  }, wt = () => {
    k.value.length && (k.value[0] && !k.value[1] ? Ze(0) : (Ze(0), Ze(1), a()), c.value = k.value.slice(), k.value[0] && k.value[1] && e.autoApply && n("auto-apply"), k.value[0] && !k.value[1] && e.modelAuto && e.autoApply && n("auto-apply"));
  }, Je = (o, b = !1) => {
    if (!(g(o.value) || !o.current && e.hideOffsetDates)) {
      if (e.weekPicker)
        return Ae(o);
      if (!e.range)
        return Se(o);
      mt(x.hours) && mt(x.minutes) && !e.multiDates && (Re(o, b), wt());
    }
  }, nt = (o) => {
    const b = o[0];
    return e.weekNumbers === "local" ? ma(b.value, { weekStartsOn: +e.weekStart }) : e.weekNumbers === "iso" ? ya(b.value) : typeof e.weekNumbers == "function" ? e.weekNumbers(b.value) : "";
  }, ze = (o) => {
    for (let b = o - 1; b >= 0; b--) {
      const X = Nt(_e(T(), { month: B.value(b + 1), year: U.value(b + 1) }), 1);
      q(b, he(X), ke(X));
    }
    for (let b = o + 1; b <= P.value.multiCalendars - 1; b++) {
      const X = ht(_e(T(), { month: B.value(b - 1), year: U.value(b - 1) }), 1);
      q(b, he(X), ke(X));
    }
  }, Z = (o) => S(T(), B.value(o), U.value(o)), oe = (o) => je(o, x.hours, x.minutes, w()), re = (o) => {
    l(Z(o));
  }, Tt = (o, b) => {
    const X = e.monthPicker ? B.value(o) !== b.month || !b.fromNav : U.value(o) !== b.year || !b.fromNav;
    if (q(o, b.month, b.year), P.value.multiCalendars && !e.multiCalendarsSolo && ze(o), e.monthPicker || e.yearPicker)
      if (e.multiDates)
        X && re(o);
      else if (e.range) {
        if (X && R(Z(o))) {
          let te = c.value ? c.value.slice() : [];
          te.length === 2 && te[1] !== null && (te = []), te.length ? Ve(Z(o), te[0]) ? te.unshift(Z(o)) : te[1] = Z(o) : te = [Z(o)], c.value = te;
        }
      } else
        c.value = Z(o);
    n("update-month-year", { instance: o, month: b.month, year: b.year }), t(e.multiCalendarsSolo ? o : void 0);
  }, vt = async (o = !1) => {
    if (e.autoApply && (e.monthPicker || e.yearPicker)) {
      await ot();
      const b = e.monthPicker ? o : !1;
      e.range ? n("auto-apply", b || !c.value || c.value.length === 1) : n("auto-apply", b);
    }
    a();
  }, Bt = (o, b) => {
    const X = _e(T(), { month: B.value(b), year: U.value(b) }), te = o < 0 ? ht(X, 1) : Nt(X, 1);
    F(he(te), ke(te), o < 0, e.preventMinMaxNavigation) && (q(b, he(te), ke(te)), P.value.multiCalendars && !e.multiCalendarsSolo && ze(b), n("update-month-year", { instance: b, month: he(te), year: ke(te) }), t());
  }, At = (o) => {
    Un(o) && Un(c.value) && mt(x.hours) && mt(x.minutes) ? (o[0] && c.value[0] && (c.value[0] = je(o[0], x.hours[0], x.minutes[0], w())), o[1] && c.value[1] && (c.value[1] = je(o[1], x.hours[1], x.minutes[1], w(!1)))) : e.multiDates && Array.isArray(c.value) ? c.value[c.value.length - 1] = oe(o) : !e.range && !Wn(o) && (c.value = oe(o)), n("time-update");
  }, Gt = (o, b = !0, X = !1) => {
    const te = b ? o : x.hours, De = !b && !X ? o : x.minutes, Qe = X ? o : x.seconds;
    if (e.range && Wn(c.value) && mt(te) && mt(De) && mt(Qe) && !e.disableTimeRangeValidation) {
      const st = (W) => je(c.value[W], te[W], De[W], Qe[W]), h = (W) => kn(c.value[W], 0);
      if (pe(c.value[0], c.value[1]) && (It(st(0), h(1)) || Ot(st(1), h(0))))
        return;
    }
    if (K("hours", te), K("minutes", De), K("seconds", Qe), c.value)
      if (e.multiDates) {
        const st = z();
        st && At(st);
      } else
        At(c.value);
    else
      e.timePicker && At(e.range ? [T(), T()] : T());
    a();
  }, Zt = (o, b) => {
    e.monthChangeOnScroll && Bt(e.monthChangeOnScroll !== "inverse" ? -o.deltaY : o.deltaY, b);
  }, qt = (o, b, X = !1) => {
    e.monthChangeOnArrows && e.vertical === X && Yt(o, b);
  }, Yt = (o, b) => {
    Bt(o === "right" ? -1 : 1, b);
  };
  return {
    time: x,
    month: B,
    year: U,
    modelValue: c,
    calendars: j,
    monthYearSelect: vt,
    isDisabled: g,
    updateTime: Gt,
    getWeekNum: nt,
    selectDate: Je,
    updateMonthYear: Tt,
    handleScroll: Zt,
    getMarker: (o) => e.markers.find((b) => pe(C(o.value), C(b.date))),
    handleArrow: qt,
    handleSwipe: Yt,
    selectCurrentDate: () => {
      e.range ? c.value && Array.isArray(c.value) && c.value[0] ? c.value = Ve(T(), c.value[0]) ? [T(), c.value[0]] : [c.value[0], T()] : c.value = [T()] : c.value = T(), Y();
    },
    presetDateRange: (o, b) => {
      b || o.length && o.length <= 2 && e.range && (c.value = o.map((X) => T(X)), Y(), e.multiCalendars && ot().then(() => se(!0)));
    }
  };
}, cl = (e, n, a) => {
  const t = H(), {
    getZonedToUtc: s,
    getZonedDate: m,
    formatDate: g,
    getDefaultPattern: C,
    checkRangeEnabled: E,
    checkPartialRangeValue: S,
    isValidDate: F,
    setDateMonthOrYear: P,
    defaults: c
  } = xe(n), k = H(""), Q = Rt(n, "format");
  dt(t, () => {
    e("internal-model-change", t.value);
  }), dt(Q, () => {
    z();
  });
  const j = (r) => {
    const Y = r || T();
    return n.modelType ? u(Y) : {
      hours: lt(Y),
      minutes: rt(Y),
      seconds: n.enableSeconds ? Dt(Y) : 0
    };
  }, x = (r) => n.modelType ? u(r) : { month: he(r), year: ke(r) }, B = (r) => Array.isArray(r) ? E(() => [
    it(T(), r[0]),
    r[1] ? it(T(), r[1]) : S()
  ]) : it(T(), +r), U = (r, Y) => (typeof r == "string" || typeof r == "number") && n.modelType ? f(r) : Y, O = (r) => Array.isArray(r) ? [
    U(
      r[0],
      je(null, +r[0].hours, +r[0].minutes, r[0].seconds)
    ),
    U(
      r[1],
      je(null, +r[1].hours, +r[1].minutes, r[1].seconds)
    )
  ] : U(r, je(null, r.hours, r.minutes, r.seconds)), q = (r) => Array.isArray(r) ? n.multiDates ? r.map((Y) => U(Y, P(null, +Y.month, +Y.year))) : E(() => [
    U(r[0], P(null, +r[0].month, +r[0].year)),
    U(
      r[1],
      r[1] ? P(null, +r[1].month, +r[1].year) : S()
    )
  ]) : U(r, P(null, +r.month, +r.year)), K = (r) => {
    if (Array.isArray(r))
      return r.map((Y) => f(Y));
    throw new Error(zt.dateArr("multi-dates"));
  }, ne = (r) => {
    if (Array.isArray(r))
      return [T(r[0]), T(r[1])];
    throw new Error(zt.dateArr("week-picker"));
  }, se = (r) => n.modelAuto ? Array.isArray(r) ? [f(r[0]), f(r[1])] : n.autoApply ? [f(r)] : [f(r), null] : Array.isArray(r) ? E(() => [
    f(r[0]),
    r[1] ? f(r[1]) : S()
  ]) : f(r), de = () => {
    Array.isArray(t.value) && n.range && t.value.length === 1 && t.value.push(S());
  }, ue = () => {
    const r = t.value;
    return [
      u(r[0]),
      r[1] ? u(r[1]) : S()
    ];
  }, ve = () => t.value[1] ? ue() : u(Pe(t.value[0])), V = () => (t.value || []).map((r) => u(r)), D = () => (de(), n.modelAuto ? ve() : n.multiDates ? V() : Array.isArray(t.value) ? E(() => ue()) : u(Pe(t.value))), d = (r) => r ? n.timePicker ? O(Pe(r)) : n.monthPicker ? q(Pe(r)) : n.yearPicker ? B(Pe(r)) : n.multiDates ? K(Pe(r)) : n.weekPicker ? ne(Pe(r)) : se(Pe(r)) : null, N = (r) => {
    const Y = d(r);
    F(Pe(Y)) ? (t.value = Pe(Y), z()) : (t.value = null, k.value = "");
  }, _ = () => {
    var Y;
    const r = (le) => {
      var Ae;
      return Ct(le, (Ae = c.value.textInputOptions) == null ? void 0 : Ae.format);
    };
    return `${r(t.value[0])} ${(Y = c.value.textInputOptions) == null ? void 0 : Y.rangeSeparator} ${t.value[1] ? r(t.value[1]) : ""}`;
  }, w = () => {
    var r;
    return a.value && t.value ? Array.isArray(t.value) ? _() : Ct(t.value, (r = c.value.textInputOptions) == null ? void 0 : r.format) : g(t.value);
  }, y = () => {
    var r;
    return t.value ? n.multiDates ? t.value.map((Y) => g(Y)).join("; ") : n.textInput && typeof ((r = c.value.textInputOptions) == null ? void 0 : r.format) == "string" ? w() : g(t.value) : "";
  }, z = () => {
    !n.format || typeof n.format == "string" ? k.value = y() : k.value = n.format(t.value);
  }, f = (r) => {
    if (n.utc) {
      const Y = new Date(r);
      return n.utc === "preserve" ? new Date(Y.getTime() + Y.getTimezoneOffset() * 6e4) : Y;
    }
    return n.modelType ? n.modelType === "date" || n.modelType === "timestamp" ? m(new Date(r)) : n.modelType === "format" && (typeof n.format == "string" || !n.format) ? dn(r, C(), /* @__PURE__ */ new Date()) : m(dn(r, n.modelType, /* @__PURE__ */ new Date())) : m(new Date(r));
  }, u = (r) => r ? n.utc ? Da(r, n.utc === "preserve", n.enableSeconds) : n.modelType ? n.modelType === "timestamp" ? +s(r) : n.modelType === "format" && (typeof n.format == "string" || !n.format) ? g(s(r)) : g(s(r), n.modelType) : s(r) : "", $ = (r) => {
    e("update:model-value", r);
  }, l = (r) => Array.isArray(t.value) ? n.multiDates ? t.value.map((Y) => r(Y)) : [
    r(t.value[0]),
    t.value[1] ? r(t.value[1]) : S()
  ] : r(Pe(t.value)), v = (r) => $(Pe(l(r)));
  return {
    inputValue: k,
    internalModelValue: t,
    checkBeforeEmit: () => t.value ? n.range ? n.partialRange ? t.value.length >= 1 : t.value.length === 2 : !!t.value : !1,
    parseExternalModelValue: N,
    formatInputValue: z,
    emitModelValue: () => (z(), n.monthPicker ? v(x) : n.timePicker ? v(j) : n.yearPicker ? v(ke) : n.weekPicker ? $(t.value) : $(D()))
  };
}, fl = (e, n) => {
  const { validateMonthYearInRange: a, validateMaxDate: t, validateMinDate: s, defaults: m } = xe(e), g = (P, c) => {
    let k = P;
    return m.value.filters.months.includes(he(k)) ? (k = c ? ht(P, 1) : Nt(P, 1), g(k, c)) : k;
  }, C = (P, c) => {
    let k = P;
    return m.value.filters.years.includes(ke(k)) ? (k = c ? ha(P, 1) : pa(P, 1), C(k, c)) : k;
  }, E = (P) => {
    const c = _e(/* @__PURE__ */ new Date(), { month: e.month, year: e.year });
    let k = P ? ht(c, 1) : Nt(c, 1);
    e.disableYearSelect && (k = it(k, e.year));
    let Q = he(k), j = ke(k);
    m.value.filters.months.includes(Q) && (k = g(k, P), Q = he(k), j = ke(k)), m.value.filters.years.includes(j) && (k = C(k, P), j = ke(k)), a(Q, j, P, e.preventMinMaxNavigation) && S(Q, j);
  }, S = (P, c) => {
    n("update-month-year", { month: P, year: c });
  }, F = L(() => (P) => {
    if (!e.preventMinMaxNavigation || P && !e.maxDate || !P && !e.minDate)
      return !1;
    const c = _e(/* @__PURE__ */ new Date(), { month: e.month, year: e.year }), k = P ? ht(c, 1) : Nt(c, 1), Q = [he(k), ke(k)];
    return P ? !t(...Q) : !s(...Q);
  });
  return { handleMonthYearChange: E, isDisabled: F, updateMonthYear: S };
};
var xt = /* @__PURE__ */ ((e) => (e.center = "center", e.left = "left", e.right = "right", e))(xt || {});
const vl = (e, n, a, t) => {
  const s = H({
    top: "0",
    left: "0",
    transform: "none",
    opacity: "0"
  }), m = H(!1), g = Rt(t, "teleportCenter"), C = L(() => m.value ? "-100%" : "0"), E = () => {
    S(), s.value.opacity = "0";
  };
  dt(g, () => {
    U();
  }), Ge(() => {
    S();
  });
  const S = () => {
    const D = Te(n);
    if (D) {
      const { top: d, left: N, width: _, height: w } = Q(D);
      s.value.top = `${d + w / 2}px`, k(N, _, 50);
    }
  }, F = (D) => {
    if (t.teleport) {
      const d = D.getBoundingClientRect();
      return {
        left: d.left + window.scrollX,
        top: d.top + window.scrollY
      };
    }
    return { top: 0, left: 0 };
  }, P = (D, d) => {
    s.value.left = `${D + d}px`, s.value.transform = `translate(-100%, ${C.value})`;
  }, c = (D) => {
    s.value.left = `${D}px`, s.value.transform = `translate(0, ${C.value})`;
  }, k = (D, d, N) => {
    t.position === xt.left && c(D), t.position === xt.right && P(D, d), t.position === xt.center && (s.value.left = `${D + d / 2}px`, s.value.transform = N ? `translate(-50%, -${N}%)` : `translate(-50%, ${C.value})`);
  }, Q = (D) => {
    const { width: d, height: N } = D.getBoundingClientRect(), { top: _, left: w } = t.altPosition ? t.altPosition(D) : F(D);
    return { top: +_, left: +w, width: d, height: N };
  }, j = () => {
    const D = Te(n);
    if (D) {
      const { top: d, left: N, width: _, height: w } = Q(D), y = se();
      s.value.top = `${d + w / 2}px`, k(N, _, y === "top" ? 100 : 0);
    }
  }, x = () => {
    s.value.left = "50%", s.value.top = "50%", s.value.transform = "translate(-50%, -50%)", s.value.position = "fixed", delete s.value.opacity;
  }, B = () => {
    const D = Te(n), { top: d, left: N, transform: _ } = t.altPosition(D);
    s.value = { top: `${d}px`, left: `${N}px`, transform: _ || "" };
  }, U = (D = !0) => {
    if (!t.inline)
      return g.value ? x() : t.altPosition !== null ? B() : (D && a("recalculate-position"), ue());
  }, O = ({
    inputEl: D,
    menuEl: d,
    left: N,
    width: _
  }) => {
    window.screen.width > 768 && k(N, _), ne(D, d);
  }, q = (D, d) => {
    const { top: N, left: _, height: w, width: y } = Q(D);
    s.value.top = `${w + N + +t.offset}px`, m.value = !1, O({ inputEl: D, menuEl: d, left: _, width: y });
  }, K = (D, d) => {
    const { top: N, left: _, width: w } = Q(D);
    s.value.top = `${N - +t.offset}px`, m.value = !0, O({ inputEl: D, menuEl: d, left: _, width: w });
  }, ne = (D, d) => {
    if (t.autoPosition) {
      const { left: N, width: _ } = Q(D), { left: w, right: y } = d.getBoundingClientRect();
      return w <= 0 ? c(N) : y >= document.documentElement.clientWidth ? P(N, _) : k(N, _);
    }
  }, se = () => {
    const D = Te(e), d = Te(n);
    if (D && d) {
      const { height: N } = D.getBoundingClientRect(), { top: _, height: w } = d.getBoundingClientRect(), z = window.innerHeight - _ - w, f = _;
      return N <= z ? "bottom" : N > z && N <= f ? "top" : z >= f ? "bottom" : "top";
    }
    return "bottom";
  }, de = (D, d) => se() === "bottom" ? q(D, d) : K(D, d), ue = () => {
    const D = Te(n), d = Te(e);
    if (D && d)
      return t.autoPosition ? de(D, d) : q(D, d);
  }, ve = function(D) {
    if (D) {
      const d = D.scrollHeight > D.clientHeight, _ = window.getComputedStyle(D).overflowY.indexOf("hidden") !== -1;
      return d && !_;
    }
    return !0;
  }, V = function(D) {
    return !D || D === document.body || D.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? window : ve(D) ? D : V(D.parentNode);
  };
  return { openOnTop: m, menuStyle: s, resetPosition: E, setMenuPosition: U, setInitialPosition: j, getScrollableParent: V };
}, bt = [
  { name: "clock-icon", use: ["time", "calendar"] },
  { name: "arrow-left", use: ["month-year", "calendar"] },
  { name: "arrow-right", use: ["month-year", "calendar"] },
  { name: "arrow-up", use: ["time", "calendar", "month-year"] },
  { name: "arrow-down", use: ["time", "calendar", "month-year"] },
  { name: "calendar-icon", use: ["month-year", "time", "calendar"] },
  { name: "day", use: ["calendar"] },
  { name: "month-overlay-value", use: ["calendar", "month-year"] },
  { name: "year-overlay-value", use: ["calendar", "month-year"] },
  { name: "year-overlay", use: ["month-year"] },
  { name: "month-overlay", use: ["month-year"] },
  { name: "month-overlay-header", use: ["month-year"] },
  { name: "year-overlay-header", use: ["month-year"] },
  { name: "hours-overlay-value", use: ["calendar", "time"] },
  { name: "minutes-overlay-value", use: ["calendar", "time"] },
  { name: "seconds-overlay-value", use: ["calendar", "time"] },
  { name: "hours", use: ["calendar", "time"] },
  { name: "minutes", use: ["calendar", "time"] },
  { name: "month", use: ["calendar", "month-year"] },
  { name: "year", use: ["calendar", "month-year"] },
  { name: "action-buttons", use: ["action"] },
  { name: "action-preview", use: ["action"] },
  { name: "calendar-header", use: ["calendar"] },
  { name: "marker-tooltip", use: ["calendar"] },
  { name: "action-extra", use: ["menu"] },
  { name: "time-picker-overlay", use: ["calendar", "time"] },
  { name: "am-pm-button", use: ["calendar", "time"] },
  { name: "left-sidebar", use: ["menu"] },
  { name: "right-sidebar", use: ["menu"] },
  { name: "month-year", use: ["month-year"] },
  { name: "time-picker", use: ["menu"] },
  { name: "action-row", use: ["action"] }
], ml = [{ name: "trigger" }, { name: "input-icon" }, { name: "clear-icon" }, { name: "dp-input" }], yl = {
  all: () => bt,
  monthYear: () => bt.filter((e) => e.use.includes("month-year")),
  input: () => ml,
  timePicker: () => bt.filter((e) => e.use.includes("time")),
  action: () => bt.filter((e) => e.use.includes("action")),
  calendar: () => bt.filter((e) => e.use.includes("calendar")),
  menu: () => bt.filter((e) => e.use.includes("menu"))
}, pt = (e, n, a) => {
  const t = [];
  return yl[n]().forEach((s) => {
    e[s.name] && t.push(s.name);
  }), a && a.length && a.forEach((s) => {
    s.slot && t.push(s.slot);
  }), t;
}, Kt = (e) => ({ transitionName: L(() => (a) => e && typeof e != "boolean" ? a ? e.open : e.close : ""), showTransition: !!e }), ft = {
  multiCalendars: { type: [Boolean, Number, String], default: null },
  modelValue: { type: [String, Date, Array, Object, Number], default: null },
  modelType: { type: String, default: null },
  position: { type: String, default: "center" },
  dark: { type: Boolean, default: !1 },
  format: {
    type: [String, Function],
    default: () => null
  },
  closeOnScroll: { type: Boolean, default: !1 },
  autoPosition: { type: Boolean, default: !0 },
  closeOnAutoApply: { type: Boolean, default: !0 },
  altPosition: { type: Function, default: null },
  transitions: { type: [Boolean, Object], default: !0 },
  formatLocale: { type: Object, default: null },
  utc: { type: [Boolean, String], default: !1 },
  ariaLabels: { type: Object, default: () => ({}) },
  offset: { type: [Number, String], default: 10 },
  hideNavigation: { type: Array, default: () => [] },
  timezone: { type: String, default: null },
  vertical: { type: Boolean, default: !1 },
  disableMonthYearSelect: { type: Boolean, default: !1 },
  disableYearSelect: { type: Boolean, default: !1 },
  menuClassName: { type: String, default: null },
  dayClass: { type: Function, default: null },
  yearRange: { type: Array, default: () => [1900, 2100] },
  multiCalendarsSolo: { type: Boolean, default: !1 },
  calendarCellClassName: { type: String, default: null },
  enableTimePicker: { type: Boolean, default: !0 },
  autoApply: { type: Boolean, default: !1 },
  disabledDates: { type: [Array, Function], default: () => [] },
  monthNameFormat: { type: String, default: "short" },
  startDate: { type: [Date, String], default: null },
  startTime: { type: [Object, Array], default: null },
  hideOffsetDates: { type: Boolean, default: !1 },
  autoRange: { type: [Number, String], default: null },
  noToday: { type: Boolean, default: !1 },
  disabledWeekDays: { type: Array, default: () => [] },
  allowedDates: { type: Array, default: () => [] },
  showNowButton: { type: Boolean, default: !1 },
  nowButtonLabel: { type: String, default: "Now" },
  markers: { type: Array, default: () => [] },
  modeHeight: { type: [Number, String], default: 255 },
  escClose: { type: Boolean, default: !0 },
  spaceConfirm: { type: Boolean, default: !0 },
  monthChangeOnArrows: { type: Boolean, default: !0 },
  presetRanges: { type: Array, default: () => [] },
  flow: { type: Array, default: () => [] },
  partialFlow: { type: Boolean, default: !1 },
  preventMinMaxNavigation: { type: Boolean, default: !1 },
  minRange: { type: [Number, String], default: null },
  maxRange: { type: [Number, String], default: null },
  multiDatesLimit: { type: [Number, String], default: null },
  reverseYears: { type: Boolean, default: !1 },
  keepActionRow: { type: Boolean, default: !1 },
  weekPicker: { type: Boolean, default: !1 },
  filters: { type: Object, default: () => ({}) },
  arrowNavigation: { type: Boolean, default: !1 },
  multiStatic: { type: Boolean, default: !0 },
  disableTimeRangeValidation: { type: Boolean, default: !1 },
  highlight: {
    type: [Array, Function],
    default: null
  },
  highlightWeekDays: {
    type: Array,
    default: null
  },
  highlightDisabledDays: { type: Boolean, default: !1 },
  teleport: { type: [String, Boolean], default: null },
  teleportCenter: { type: Boolean, default: !1 },
  locale: { type: String, default: "en-Us" },
  weekNumName: { type: String, default: "W" },
  weekStart: { type: [Number, String], default: 1 },
  weekNumbers: {
    type: [String, Function],
    default: null
  },
  calendarClassName: { type: String, default: null },
  noSwipe: { type: Boolean, default: !1 },
  monthChangeOnScroll: { type: [Boolean, String], default: !0 },
  dayNames: {
    type: [Function, Array],
    default: null
  },
  monthPicker: { type: Boolean, default: !1 },
  customProps: { type: Object, default: null },
  yearPicker: { type: Boolean, default: !1 },
  modelAuto: { type: Boolean, default: !1 },
  selectText: { type: String, default: "Select" },
  cancelText: { type: String, default: "Cancel" },
  previewFormat: {
    type: [String, Function],
    default: () => ""
  },
  multiDates: { type: Boolean, default: !1 },
  partialRange: { type: Boolean, default: !0 },
  ignoreTimeValidation: { type: Boolean, default: !1 },
  minDate: { type: [Date, String], default: null },
  maxDate: { type: [Date, String], default: null },
  minTime: { type: Object, default: null },
  maxTime: { type: Object, default: null },
  name: { type: String, default: null },
  placeholder: { type: String, default: "" },
  hideInputIcon: { type: Boolean, default: !1 },
  clearable: { type: Boolean, default: !0 },
  state: { type: Boolean, default: null },
  required: { type: Boolean, default: !1 },
  autocomplete: { type: String, default: "off" },
  inputClassName: { type: String, default: null },
  inlineWithInput: { type: Boolean, default: !1 },
  textInputOptions: { type: Object, default: () => null },
  fixedStart: { type: Boolean, default: !1 },
  fixedEnd: { type: Boolean, default: !1 },
  timePicker: { type: Boolean, default: !1 },
  enableSeconds: { type: Boolean, default: !1 },
  is24: { type: Boolean, default: !0 },
  noHoursOverlay: { type: Boolean, default: !1 },
  noMinutesOverlay: { type: Boolean, default: !1 },
  noSecondsOverlay: { type: Boolean, default: !1 },
  hoursGridIncrement: { type: [String, Number], default: 1 },
  minutesGridIncrement: { type: [String, Number], default: 5 },
  secondsGridIncrement: { type: [String, Number], default: 5 },
  hoursIncrement: { type: [Number, String], default: 1 },
  minutesIncrement: { type: [Number, String], default: 1 },
  secondsIncrement: { type: [Number, String], default: 1 },
  range: { type: Boolean, default: !1 },
  uid: { type: String, default: null },
  disabled: { type: Boolean, default: !1 },
  readonly: { type: Boolean, default: !1 },
  inline: { type: Boolean, default: !1 },
  textInput: { type: Boolean, default: !1 },
  onClickOutside: { type: Function, default: null },
  noDisabledRange: { type: Boolean, default: !1 },
  sixWeeks: { type: [Boolean, String], default: !1 },
  actionRow: { type: Object, default: () => ({}) },
  allowPreventDefault: { type: Boolean, default: !1 },
  closeOnClearValue: { type: Boolean, default: !0 },
  focusStartDate: { type: Boolean, default: !1 },
  disabledTimes: { type: Function, default: void 0 },
  showLastInRange: { type: Boolean, default: !0 }
}, gl = {
  key: 1,
  class: "dp__input_wrap"
}, hl = ["id", "name", "inputmode", "placeholder", "disabled", "readonly", "required", "value", "autocomplete", "aria-label", "onKeydown"], pl = {
  key: 0,
  class: "dp__input_icon"
}, kl = {
  key: 2,
  class: "dp__clear_icon"
}, wl = /* @__PURE__ */ Xe({
  __name: "DatepickerInput",
  props: {
    isMenuOpen: { type: Boolean, default: !1 },
    inputValue: { type: String, default: "" },
    ...ft
  },
  emits: [
    "clear",
    "open",
    "update:input-value",
    "set-input-date",
    "close",
    "select-date",
    "set-empty-date",
    "toggle",
    "focus-prev",
    "focus",
    "blur",
    "real-blur"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, { getDefaultPattern: s, isValidDate: m, defaults: g, getDefaultStartTime: C, assignDefaultTime: E } = xe(t), S = H(), F = H(null), P = H(!1), c = H(!1), k = L(
      () => ({
        dp__pointer: !t.disabled && !t.readonly && !t.textInput,
        dp__disabled: t.disabled,
        dp__input_readonly: !t.textInput,
        dp__input: !0,
        dp__input_icon_pad: !t.hideInputIcon,
        dp__input_valid: t.state,
        dp__input_invalid: t.state === !1,
        dp__input_focus: P.value || t.isMenuOpen,
        dp__input_reg: !t.textInput,
        [t.inputClassName]: !!t.inputClassName
      })
    ), Q = () => {
      a("set-input-date", null), t.autoApply && (a("set-empty-date"), S.value = null);
    }, j = (d) => {
      var _;
      const N = C();
      return ba(
        d,
        ((_ = g.value.textInputOptions) == null ? void 0 : _.format) || s(),
        N || E({}),
        t.inputValue,
        c.value
      );
    }, x = (d) => {
      const { rangeSeparator: N } = g.value.textInputOptions, [_, w] = d.split(`${N}`);
      if (_) {
        const y = j(_.trim()), z = w ? j(w.trim()) : null, f = y && z ? [y, z] : [y];
        S.value = y ? f : null;
      }
    }, B = () => {
      c.value = !0;
    }, U = (d) => {
      if (t.range)
        x(d);
      else if (t.multiDates) {
        const N = d.split(";");
        S.value = N.map((_) => j(_.trim())).filter((_) => _);
      } else
        S.value = j(d);
    }, O = (d) => {
      var _;
      const { value: N } = d.target;
      N !== "" ? ((_ = g.value.textInputOptions) != null && _.openMenu && !t.isMenuOpen && a("open"), U(N), a("set-input-date", S.value)) : Q(), c.value = !1, a("update:input-value", N);
    }, q = (d) => {
      var N, _;
      t.textInput ? (U(d.target.value), (N = g.value.textInputOptions) != null && N.enterSubmit && m(S.value) && t.inputValue !== "" ? (a("set-input-date", S.value, !0), S.value = null) : (_ = g.value.textInputOptions) != null && _.enterSubmit && t.inputValue === "" && (S.value = null, a("clear"))) : se(d);
    }, K = (d) => {
      var N, _, w;
      t.textInput && ((N = g.value.textInputOptions) != null && N.tabSubmit) && U(d.target.value), (_ = g.value.textInputOptions) != null && _.tabSubmit && m(S.value) && t.inputValue !== "" ? (a("set-input-date", S.value, !0), S.value = null) : (w = g.value.textInputOptions) != null && w.tabSubmit && t.inputValue === "" && (S.value = null, a("clear"));
    }, ne = () => {
      P.value = !0, a("focus");
    }, se = (d) => {
      var N;
      d.preventDefault(), d.stopImmediatePropagation(), d.stopPropagation(), t.textInput && ((N = g.value.textInputOptions) != null && N.openMenu) && !t.inlineWithInput ? (a("toggle"), g.value.textInputOptions.enterSubmit && a("select-date")) : t.textInput || a("toggle");
    }, de = () => {
      a("real-blur"), P.value = !1, t.isMenuOpen || a("blur"), t.autoApply && t.textInput && S.value && !t.isMenuOpen && (a("set-input-date", S.value), a("select-date"), S.value = null);
    }, ue = () => {
      a("clear");
    }, ve = (d) => {
      if (!t.textInput) {
        if (d.code === "Tab")
          return;
        d.preventDefault();
      }
    };
    return n({
      focusInput: () => {
        var d;
        (d = F.value) == null || d.focus({ preventScroll: !0 });
      },
      setParsedDate: (d) => {
        S.value = d;
      }
    }), (d, N) => {
      var _;
      return p(), I("div", { onClick: se }, [
        d.$slots.trigger && !d.$slots["dp-input"] && !d.inline ? G(d.$slots, "trigger", { key: 0 }) : A("", !0),
        !d.$slots.trigger && (!d.inline || d.inlineWithInput) ? (p(), I("div", gl, [
          d.$slots["dp-input"] && !d.$slots.trigger && !d.inline ? G(d.$slots, "dp-input", {
            key: 0,
            value: e.inputValue,
            isMenuOpen: e.isMenuOpen,
            onInput: O,
            onEnter: q,
            onTab: K,
            onClear: ue,
            onBlur: de,
            onKeypress: ve,
            onPaste: B
          }) : A("", !0),
          d.$slots["dp-input"] ? A("", !0) : (p(), I("input", {
            key: 1,
            ref_key: "inputRef",
            ref: F,
            id: d.uid ? `dp-input-${d.uid}` : void 0,
            name: d.name,
            class: ge(k.value),
            inputmode: d.textInput ? "text" : "none",
            placeholder: d.placeholder,
            disabled: d.disabled,
            readonly: d.readonly,
            required: d.required,
            value: e.inputValue,
            autocomplete: d.autocomplete,
            "aria-label": (_ = M(g).ariaLabels) == null ? void 0 : _.input,
            onInput: O,
            onKeydown: [
              ie(q, ["enter"]),
              ie(K, ["tab"]),
              ve
            ],
            onBlur: de,
            onFocus: ne,
            onKeypress: ve,
            onPaste: B
          }, null, 42, hl)),
          ae("div", {
            onClick: N[0] || (N[0] = (w) => a("toggle"))
          }, [
            d.$slots["input-icon"] && !d.hideInputIcon ? (p(), I("span", pl, [
              G(d.$slots, "input-icon")
            ])) : A("", !0),
            !d.$slots["input-icon"] && !d.hideInputIcon && !d.$slots["dp-input"] ? (p(), me(M(jt), {
              key: 1,
              class: "dp__input_icon dp__input_icons"
            })) : A("", !0)
          ]),
          d.$slots["clear-icon"] && e.inputValue && d.clearable && !d.disabled && !d.readonly ? (p(), I("span", kl, [
            G(d.$slots, "clear-icon", { clear: ue })
          ])) : A("", !0),
          d.clearable && !d.$slots["clear-icon"] && e.inputValue && !d.disabled && !d.readonly ? (p(), me(M(wa), {
            key: 3,
            class: "dp__clear_icon dp__input_icons",
            onClick: He(ue, ["stop", "prevent"])
          }, null, 8, ["onClick"])) : A("", !0)
        ])) : A("", !0)
      ]);
    };
  }
}), bl = ["title"], Dl = { class: "dp__action_buttons" }, $l = ["onKeydown", "disabled"], Ml = /* @__PURE__ */ Xe({
  __name: "ActionRow",
  props: {
    menuMount: { type: Boolean, default: !1 },
    internalModelValue: { type: [Date, Array], default: null },
    calendarWidth: { type: Number, default: 0 },
    ...ft
  },
  emits: ["close-picker", "select-date", "select-now", "invalid-select"],
  setup(e, { emit: n }) {
    const a = e, { formatDate: t, isValidTime: s, defaults: m } = xe(a), { buildMatrix: g } = ct(), C = H(null), E = H(null);
    Ge(() => {
      a.arrowNavigation && g([Te(C), Te(E)], "actionRow");
    });
    const S = L(() => a.range && !a.partialRange && a.internalModelValue ? a.internalModelValue.length === 2 : !0), F = L(() => !P.value || !c.value || !S.value), P = L(() => !a.enableTimePicker || a.ignoreTimeValidation ? !0 : s(a.internalModelValue)), c = L(() => a.monthPicker ? a.range && Array.isArray(a.internalModelValue) ? !a.internalModelValue.filter((q) => !B(q)).length : B(a.internalModelValue) : !0), k = () => {
      const O = m.value.previewFormat;
      return a.timePicker || a.monthPicker, O(Pe(a.internalModelValue));
    }, Q = () => {
      const O = a.internalModelValue;
      return m.value.multiCalendars > 0 ? `${t(O[0])} - ${t(O[1])}` : [t(O[0]), t(O[1])];
    }, j = L(() => !a.internalModelValue || !a.menuMount ? "" : typeof m.value.previewFormat == "string" ? Array.isArray(a.internalModelValue) ? a.internalModelValue.length === 2 && a.internalModelValue[1] ? Q() : a.multiDates ? a.internalModelValue.map((O) => `${t(O)}`) : a.modelAuto ? `${t(a.internalModelValue[0])}` : `${t(a.internalModelValue[0])} -` : t(a.internalModelValue) : k()), x = L(
      () => Array.isArray(j.value) ? j.value.join(a.multiDates ? "; " : " - ") : j.value
    ), B = (O) => {
      if (!a.monthPicker)
        return !0;
      let q = !0;
      const K = T(St(O));
      if (a.minDate && a.maxDate) {
        const ne = T(St(a.minDate)), se = T(St(a.maxDate));
        return Fe(K, ne) && Ve(K, se) || pe(K, ne) || pe(K, se);
      }
      if (a.minDate) {
        const ne = T(St(a.minDate));
        q = Fe(K, ne) || pe(K, ne);
      }
      if (a.maxDate) {
        const ne = T(St(a.maxDate));
        q = Ve(K, ne) || pe(K, ne);
      }
      return q;
    }, U = () => {
      P.value && c.value && S.value ? n("select-date") : n("invalid-select");
    };
    return (O, q) => (p(), I("div", {
      class: "dp__action_row",
      style: ut(e.calendarWidth ? { width: `${e.calendarWidth}px` } : {})
    }, [
      O.$slots["action-row"] ? G(O.$slots, "action-row", Be(Ce({ key: 0 }, {
        internalModelValue: e.internalModelValue,
        disabled: F.value,
        selectDate: () => O.$emit("select-date"),
        closePicker: () => O.$emit("close-picker")
      }))) : (p(), I(ye, { key: 1 }, [
        M(m).actionRow.showPreview ? (p(), I("div", {
          key: 0,
          class: "dp__selection_preview",
          title: x.value
        }, [
          O.$slots["action-preview"] ? G(O.$slots, "action-preview", {
            key: 0,
            value: e.internalModelValue
          }) : A("", !0),
          O.$slots["action-preview"] ? A("", !0) : (p(), I(ye, { key: 1 }, [
            tt(Ye(x.value), 1)
          ], 64))
        ], 8, bl)) : A("", !0),
        ae("div", Dl, [
          O.$slots["action-buttons"] ? G(O.$slots, "action-buttons", {
            key: 0,
            value: e.internalModelValue
          }) : A("", !0),
          O.$slots["action-buttons"] ? A("", !0) : (p(), I(ye, { key: 1 }, [
            !O.inline && M(m).actionRow.showCancel ? (p(), I("button", {
              key: 0,
              type: "button",
              ref_key: "cancelButtonRef",
              ref: C,
              class: "dp__action_button dp__action_cancel",
              onClick: q[0] || (q[0] = (K) => O.$emit("close-picker")),
              onKeydown: [
                q[1] || (q[1] = ie((K) => O.$emit("close-picker"), ["enter"])),
                q[2] || (q[2] = ie((K) => O.$emit("close-picker"), ["space"]))
              ]
            }, Ye(O.cancelText), 545)) : A("", !0),
            O.showNowButton || M(m).actionRow.showNow ? (p(), I("button", {
              key: 1,
              type: "button",
              ref_key: "cancelButtonRef",
              ref: C,
              class: "dp__action_button dp__action_cancel",
              onClick: q[3] || (q[3] = (K) => O.$emit("select-now")),
              onKeydown: [
                q[4] || (q[4] = ie((K) => O.$emit("select-now"), ["enter"])),
                q[5] || (q[5] = ie((K) => O.$emit("select-now"), ["space"]))
              ]
            }, Ye(O.nowButtonLabel), 545)) : A("", !0),
            M(m).actionRow.showSelect ? (p(), I("button", {
              key: 2,
              type: "button",
              class: "dp__action_button dp__action_select",
              onKeydown: [
                ie(U, ["enter"]),
                ie(U, ["space"])
              ],
              onClick: U,
              disabled: F.value,
              ref_key: "selectButtonRef",
              ref: E
            }, Ye(O.selectText), 41, $l)) : A("", !0)
          ], 64))
        ])
      ], 64))
    ], 4));
  }
}), Tl = ["aria-label"], Al = {
  class: "dp__calendar_header",
  role: "row"
}, Sl = {
  key: 0,
  class: "dp__calendar_header_item",
  role: "gridcell"
}, Pl = /* @__PURE__ */ ae("div", { class: "dp__calendar_header_separator" }, null, -1), Cl = ["aria-label"], Nl = {
  key: 0,
  role: "gridcell",
  class: "dp__calendar_item dp__week_num"
}, _l = { class: "dp__cell_inner" }, Rl = ["aria-selected", "aria-disabled", "aria-label", "onClick", "onKeydown", "onMouseenter", "onMouseleave"], Ol = /* @__PURE__ */ Xe({
  __name: "Calendar",
  props: {
    mappedDates: { type: Array, default: () => [] },
    getWeekNum: {
      type: Function,
      default: () => ""
    },
    specificMode: { type: Boolean, default: !1 },
    instance: { type: Number, default: 0 },
    month: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    ...ft
  },
  emits: [
    "select-date",
    "set-hover-date",
    "handle-scroll",
    "mount",
    "handle-swipe",
    "handle-space",
    "tooltip-open",
    "tooltip-close"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, { buildMultiLevelMatrix: s } = ct(), { setDateMonthOrYear: m, defaults: g } = xe(t), C = H(null), E = H({
      bottom: "",
      left: "",
      transform: ""
    }), S = H([]), F = H(null), P = H(!0), c = H(""), k = H({ startX: 0, endX: 0, startY: 0, endY: 0 }), Q = H([]), j = H({ left: "50%" }), x = L(() => t.dayNames ? Array.isArray(t.dayNames) ? t.dayNames : t.dayNames(t.locale, +t.weekStart) : Xa(t.locale, +t.weekStart));
    Ge(() => {
      a("mount", { cmp: "calendar", refs: S }), t.noSwipe || F.value && (F.value.addEventListener("touchstart", V, { passive: !1 }), F.value.addEventListener("touchend", D, { passive: !1 }), F.value.addEventListener("touchmove", d, { passive: !1 })), t.monthChangeOnScroll && F.value && F.value.addEventListener("wheel", w, { passive: !1 });
    });
    const B = (y) => y ? t.vertical ? "vNext" : "next" : t.vertical ? "vPrevious" : "previous", U = (y, z) => {
      if (t.transitions) {
        const f = Ke(m(T(), t.month, t.year));
        c.value = Fe(Ke(m(T(), y, z)), f) ? g.value.transitions[B(!0)] : g.value.transitions[B(!1)], P.value = !1, ot(() => {
          P.value = !0;
        });
      }
    }, O = L(
      () => ({
        [t.calendarClassName]: !!t.calendarClassName
      })
    ), q = L(() => (y) => {
      const z = tl(y);
      return {
        dp__marker_dot: z.type === "dot",
        dp__marker_line: z.type === "line"
      };
    }), K = L(() => (y) => pe(y, C.value)), ne = L(() => ({
      dp__calendar: !0,
      dp__calendar_next: g.value.multiCalendars > 0 && t.instance !== 0
    })), se = L(() => (y) => t.hideOffsetDates ? y.current : !0), de = L(() => t.specificMode ? { height: `${t.modeHeight}px` } : void 0), ue = async (y, z, f) => {
      var u, $;
      if (a("set-hover-date", y), ($ = (u = y.marker) == null ? void 0 : u.tooltip) != null && $.length) {
        const l = Te(S.value[z][f]);
        if (l) {
          const { width: v, height: R } = l.getBoundingClientRect();
          C.value = y.value;
          let i = { left: `${v / 2}px` }, r = -50;
          if (await ot(), Q.value[0]) {
            const { left: Y, width: le } = Q.value[0].getBoundingClientRect();
            Y < 0 && (i = { left: "0" }, r = 0, j.value.left = `${v / 2}px`), window.innerWidth < Y + le && (i = { right: "0" }, r = 0, j.value.left = `${le - v / 2}px`);
          }
          E.value = {
            bottom: `${R}px`,
            ...i,
            transform: `translateX(${r}%)`
          }, a("tooltip-open", y.marker);
        }
      }
    }, ve = (y) => {
      C.value && (C.value = null, E.value = JSON.parse(JSON.stringify({ bottom: "", left: "", transform: "" })), a("tooltip-close", y.marker));
    }, V = (y) => {
      k.value.startX = y.changedTouches[0].screenX, k.value.startY = y.changedTouches[0].screenY;
    }, D = (y) => {
      k.value.endX = y.changedTouches[0].screenX, k.value.endY = y.changedTouches[0].screenY, N();
    }, d = (y) => {
      t.vertical && !t.inline && y.preventDefault();
    }, N = () => {
      const y = t.vertical ? "Y" : "X";
      Math.abs(k.value[`start${y}`] - k.value[`end${y}`]) > 10 && a("handle-swipe", k.value[`start${y}`] > k.value[`end${y}`] ? "right" : "left");
    }, _ = (y, z, f) => {
      y && (Array.isArray(S.value[z]) ? S.value[z][f] = y : S.value[z] = [y]), t.arrowNavigation && s(S.value, "calendar");
    }, w = (y) => {
      t.monthChangeOnScroll && (y.preventDefault(), a("handle-scroll", y));
    };
    return n({ triggerTransition: U }), (y, z) => {
      var f;
      return p(), I("div", {
        class: ge(ne.value)
      }, [
        ae("div", {
          style: ut(de.value),
          ref_key: "calendarWrapRef",
          ref: F,
          role: "grid",
          class: ge(O.value),
          "aria-label": (f = M(g).ariaLabels) == null ? void 0 : f.calendarWrap
        }, [
          e.specificMode ? A("", !0) : (p(), I(ye, { key: 0 }, [
            ae("div", Al, [
              y.weekNumbers ? (p(), I("div", Sl, Ye(y.weekNumName), 1)) : A("", !0),
              (p(!0), I(ye, null, Ne(x.value, (u, $) => (p(), I("div", {
                class: "dp__calendar_header_item",
                role: "gridcell",
                key: $
              }, [
                y.$slots["calendar-header"] ? G(y.$slots, "calendar-header", {
                  key: 0,
                  day: u,
                  index: $
                }) : A("", !0),
                y.$slots["calendar-header"] ? A("", !0) : (p(), I(ye, { key: 1 }, [
                  tt(Ye(u), 1)
                ], 64))
              ]))), 128))
            ]),
            Pl,
            kt(Mt, {
              name: c.value,
              css: !!y.transitions
            }, {
              default: ce(() => {
                var u;
                return [
                  P.value ? (p(), I("div", {
                    key: 0,
                    class: "dp__calendar",
                    role: "grid",
                    "aria-label": (u = M(g).ariaLabels) == null ? void 0 : u.calendarDays
                  }, [
                    (p(!0), I(ye, null, Ne(e.mappedDates, ($, l) => (p(), I("div", {
                      class: "dp__calendar_row",
                      role: "row",
                      key: l
                    }, [
                      y.weekNumbers ? (p(), I("div", Nl, [
                        ae("div", _l, Ye(e.getWeekNum($.days)), 1)
                      ])) : A("", !0),
                      (p(!0), I(ye, null, Ne($.days, (v, R) => {
                        var i, r, Y;
                        return p(), I("div", {
                          role: "gridcell",
                          class: "dp__calendar_item",
                          ref_for: !0,
                          ref: (le) => _(le, l, R),
                          key: R + l,
                          "aria-selected": v.classData.dp__active_date || v.classData.dp__range_start || v.classData.dp__range_start,
                          "aria-disabled": v.classData.dp__cell_disabled,
                          "aria-label": (r = (i = M(g).ariaLabels) == null ? void 0 : i.day) == null ? void 0 : r.call(i, v),
                          tabindex: "0",
                          onClick: He((le) => y.$emit("select-date", v), ["stop", "prevent"]),
                          onKeydown: [
                            ie((le) => y.$emit("select-date", v), ["enter"]),
                            ie((le) => y.$emit("handle-space", v), ["space"])
                          ],
                          onMouseenter: (le) => ue(v, l, R),
                          onMouseleave: (le) => ve(v)
                        }, [
                          ae("div", {
                            class: ge(["dp__cell_inner", v.classData])
                          }, [
                            y.$slots.day && se.value(v) ? G(y.$slots, "day", {
                              key: 0,
                              day: +v.text,
                              date: v.value
                            }) : A("", !0),
                            y.$slots.day ? A("", !0) : (p(), I(ye, { key: 1 }, [
                              tt(Ye(v.text), 1)
                            ], 64)),
                            v.marker && se.value(v) ? (p(), I("div", {
                              key: 2,
                              class: ge(q.value(v.marker)),
                              style: ut(v.marker.color ? { backgroundColor: v.marker.color } : {})
                            }, null, 6)) : A("", !0),
                            K.value(v.value) ? (p(), I("div", {
                              key: 3,
                              class: "dp__marker_tooltip",
                              ref_for: !0,
                              ref_key: "activeTooltip",
                              ref: Q,
                              style: ut(E.value)
                            }, [
                              (Y = v.marker) != null && Y.tooltip ? (p(), I("div", {
                                key: 0,
                                class: "dp__tooltip_content",
                                onClick: z[0] || (z[0] = He(() => {
                                }, ["stop"]))
                              }, [
                                (p(!0), I(ye, null, Ne(v.marker.tooltip, (le, Ae) => (p(), I("div", {
                                  key: Ae,
                                  class: "dp__tooltip_text"
                                }, [
                                  y.$slots["marker-tooltip"] ? G(y.$slots, "marker-tooltip", {
                                    key: 0,
                                    tooltip: le,
                                    day: v.value
                                  }) : A("", !0),
                                  y.$slots["marker-tooltip"] ? A("", !0) : (p(), I(ye, { key: 1 }, [
                                    ae("div", {
                                      class: "dp__tooltip_mark",
                                      style: ut(le.color ? { backgroundColor: le.color } : {})
                                    }, null, 4),
                                    ae("div", null, Ye(le.text), 1)
                                  ], 64))
                                ]))), 128)),
                                ae("div", {
                                  class: "dp__arrow_bottom_tp",
                                  style: ut(j.value)
                                }, null, 4)
                              ])) : A("", !0)
                            ], 4)) : A("", !0)
                          ], 2)
                        ], 40, Rl);
                      }), 128))
                    ]))), 128))
                  ], 8, Cl)) : A("", !0)
                ];
              }),
              _: 3
            }, 8, ["name", "css"])
          ], 64))
        ], 14, Tl)
      ], 2);
    };
  }
}), Il = ["aria-label", "aria-disabled"], sn = /* @__PURE__ */ Xe({
  __name: "ActionIcon",
  props: {
    ariaLabel: {},
    disabled: { type: Boolean }
  },
  emits: ["activate", "set-ref"],
  setup(e, { emit: n }) {
    const a = H(null);
    return Ge(() => n("set-ref", a)), (t, s) => (p(), I("button", {
      type: "button",
      class: "dp__btn dp__month_year_col_nav",
      onClick: s[0] || (s[0] = (m) => t.$emit("activate")),
      onKeydown: [
        s[1] || (s[1] = ie(He((m) => t.$emit("activate"), ["prevent"]), ["enter"])),
        s[2] || (s[2] = ie(He((m) => t.$emit("activate"), ["prevent"]), ["space"]))
      ],
      tabindex: "0",
      "aria-label": t.ariaLabel,
      "aria-disabled": t.disabled,
      ref_key: "elRef",
      ref: a
    }, [
      ae("span", {
        class: ge(["dp__inner_nav", { dp__inner_nav_disabled: t.disabled }])
      }, [
        G(t.$slots, "default")
      ], 2)
    ], 40, Il));
  }
}), Bl = ["onKeydown"], Yl = { class: "dp__selection_grid_header" }, Vl = ["aria-selected", "aria-disabled", "onClick", "onKeydown", "onMouseover"], El = ["aria-label", "onKeydown"], _t = /* @__PURE__ */ Xe({
  __name: "SelectionGrid",
  props: {
    items: { type: Array, default: () => [] },
    modelValue: { type: [String, Number], default: null },
    multiModelValue: { type: Array, default: () => [] },
    disabledValues: { type: Array, default: () => [] },
    minValue: { type: [Number, String], default: null },
    maxValue: { type: [Number, String], default: null },
    year: { type: Number, default: 0 },
    skipActive: { type: Boolean, default: !1 },
    headerRefs: { type: Array, default: () => [] },
    skipButtonRef: { type: Boolean, default: !1 },
    monthPicker: { type: Boolean, default: !1 },
    yearPicker: { type: Boolean, default: !1 },
    escClose: { type: Boolean, default: !0 },
    type: { type: String, default: null },
    arrowNavigation: { type: Boolean, default: !1 },
    autoApply: { type: Boolean, default: !1 },
    textInput: { type: Boolean, default: !1 },
    ariaLabels: { type: Object, default: () => ({}) },
    hideNavigation: { type: Array, default: () => [] }
  },
  emits: ["update:model-value", "selected", "toggle", "reset-flow"],
  setup(e, { expose: n, emit: a }) {
    const t = e, { setSelectionGrid: s, buildMultiLevelMatrix: m, setMonthPicker: g } = ct(), { hideNavigationButtons: C } = xe(t), E = H(!1), S = H(null), F = H(null), P = H([]), c = H(), k = H(null), Q = H(0), j = H(null);
    oa(() => {
      S.value = null;
    }), Ge(() => {
      ot().then(() => ue()), B(), x(!0);
    }), hn(() => x(!1));
    const x = (w) => {
      var y;
      t.arrowNavigation && ((y = t.headerRefs) != null && y.length ? g(w) : s(w));
    }, B = () => {
      const w = Te(F);
      w && (t.textInput || w.focus({ preventScroll: !0 }), E.value = w.clientHeight < w.scrollHeight);
    }, U = L(
      () => ({
        dp__overlay: !0
      })
    ), O = L(() => ({
      dp__overlay_col: !0
    })), q = (w) => t.skipActive ? !1 : w.value === t.modelValue, K = L(() => t.items.map((w) => w.filter((y) => y).map((y) => {
      var u, $, l;
      const z = t.disabledValues.some((v) => v === y.value) || de(y.value), f = (u = t.multiModelValue) != null && u.length ? ($ = t.multiModelValue) == null ? void 0 : $.some(
        (v) => pe(
          v,
          it(
            t.monthPicker ? Ht(/* @__PURE__ */ new Date(), y.value) : /* @__PURE__ */ new Date(),
            t.monthPicker ? t.year : y.value
          )
        )
      ) : q(y);
      return {
        ...y,
        className: {
          dp__overlay_cell_active: f,
          dp__overlay_cell: !f,
          dp__overlay_cell_disabled: z,
          dp__overlay_cell_active_disabled: z && f,
          dp__overlay_cell_pad: !0,
          dp__cell_in_between: (l = t.multiModelValue) != null && l.length && t.skipActive ? V(y.value) : !1
        }
      };
    }))), ne = L(
      () => ({
        dp__button: !0,
        dp__overlay_action: !0,
        dp__over_action_scroll: E.value,
        dp__button_bottom: t.autoApply
      })
    ), se = L(() => {
      var w, y;
      return {
        dp__overlay_container: !0,
        dp__container_flex: ((w = t.items) == null ? void 0 : w.length) <= 6,
        dp__container_block: ((y = t.items) == null ? void 0 : y.length) > 6
      };
    }), de = (w) => {
      const y = t.maxValue || t.maxValue === 0, z = t.minValue || t.minValue === 0;
      return !y && !z ? !1 : y && z ? +w > +t.maxValue || +w < +t.minValue : y ? +w > +t.maxValue : z ? +w < +t.minValue : !1;
    }, ue = () => {
      const w = Te(S), y = Te(F), z = Te(k), f = Te(j), u = z ? z.getBoundingClientRect().height : 0;
      y && (Q.value = y.getBoundingClientRect().height - u), w && f && (f.scrollTop = w.offsetTop - f.offsetTop - (Q.value / 2 - w.getBoundingClientRect().height) - u);
    }, ve = (w) => {
      !t.disabledValues.some((y) => y === w) && !de(w) && (a("update:model-value", w), a("selected"));
    }, V = (w) => {
      const y = t.monthPicker ? t.year : w;
      return Jn(
        t.multiModelValue,
        it(
          t.monthPicker ? Ht(/* @__PURE__ */ new Date(), c.value || 0) : /* @__PURE__ */ new Date(),
          t.monthPicker ? y : c.value || y
        ),
        it(t.monthPicker ? Ht(/* @__PURE__ */ new Date(), w) : /* @__PURE__ */ new Date(), y)
      );
    }, D = () => {
      a("toggle"), a("reset-flow");
    }, d = () => {
      t.escClose && D();
    }, N = (w, y, z, f) => {
      w && (y.value === +t.modelValue && !t.disabledValues.includes(y.value) && (S.value = w), t.arrowNavigation && (Array.isArray(P.value[z]) ? P.value[z][f] = w : P.value[z] = [w], _()));
    }, _ = () => {
      var y, z;
      const w = (y = t.headerRefs) != null && y.length ? [t.headerRefs].concat(P.value) : P.value.concat([t.skipButtonRef ? [] : [k.value]]);
      m(Pe(w), (z = t.headerRefs) != null && z.length ? "monthPicker" : "selectionGrid");
    };
    return n({ focusGrid: B }), (w, y) => {
      var z;
      return p(), I("div", {
        ref_key: "gridWrapRef",
        ref: F,
        class: ge(U.value),
        role: "dialog",
        tabindex: "0",
        onKeydown: ie(d, ["esc"])
      }, [
        ae("div", {
          class: ge(se.value),
          ref_key: "containerRef",
          ref: j,
          role: "grid",
          style: ut({ height: `${Q.value}px` })
        }, [
          ae("div", Yl, [
            G(w.$slots, "header")
          ]),
          w.$slots.overlay ? G(w.$slots, "overlay", { key: 0 }) : (p(!0), I(ye, { key: 1 }, Ne(K.value, (f, u) => (p(), I("div", {
            class: ge(["dp__overlay_row", { dp__flex_row: K.value.length >= 3 }]),
            key: u,
            role: "row"
          }, [
            (p(!0), I(ye, null, Ne(f, ($, l) => (p(), I("div", {
              role: "gridcell",
              class: ge(O.value),
              key: $.value,
              "aria-selected": $.value === e.modelValue && !e.disabledValues.includes($.value),
              "aria-disabled": $.className.dp__overlay_cell_disabled,
              ref_for: !0,
              ref: (v) => N(v, $, u, l),
              tabindex: "0",
              onClick: (v) => ve($.value),
              onKeydown: [
                ie((v) => ve($.value), ["enter"]),
                ie((v) => ve($.value), ["space"])
              ],
              onMouseover: (v) => c.value = $.value
            }, [
              ae("div", {
                class: ge($.className)
              }, [
                w.$slots.item ? G(w.$slots, "item", {
                  key: 0,
                  item: $
                }) : A("", !0),
                w.$slots.item ? A("", !0) : (p(), I(ye, { key: 1 }, [
                  tt(Ye($.text), 1)
                ], 64))
              ], 2)
            ], 42, Vl))), 128))
          ], 2))), 128))
        ], 6),
        w.$slots["button-icon"] ? Ft((p(), I("div", {
          key: 0,
          role: "button",
          "aria-label": (z = e.ariaLabels) == null ? void 0 : z.toggleOverlay,
          class: ge(ne.value),
          tabindex: "0",
          ref_key: "toggleButton",
          ref: k,
          onClick: D,
          onKeydown: [
            ie(D, ["enter"]),
            ie(D, ["tab"])
          ]
        }, [
          G(w.$slots, "button-icon")
        ], 42, El)), [
          [Ut, !M(C)(e.type)]
        ]) : A("", !0)
      ], 42, Bl);
    };
  }
}), Ll = ["aria-label"], Hn = /* @__PURE__ */ Xe({
  __name: "RegularPicker",
  props: {
    ariaLabel: { type: String, default: "" },
    showSelectionGrid: { type: Boolean, default: !1 },
    modelValue: { type: Number, default: null },
    items: { type: Array, default: () => [] },
    disabledValues: { type: Array, default: () => [] },
    minValue: { type: Number, default: null },
    maxValue: { type: Number, default: null },
    slotName: { type: String, default: "" },
    overlaySlot: { type: String, default: "" },
    headerRefs: { type: Array, default: () => [] },
    escClose: { type: Boolean, default: !0 },
    type: { type: String, default: null },
    transitions: { type: [Object, Boolean], default: !1 },
    arrowNavigation: { type: Boolean, default: !1 },
    autoApply: { type: Boolean, default: !1 },
    textInput: { type: Boolean, default: !1 },
    ariaLabels: { type: Object, default: () => ({}) },
    hideNavigation: { type: Array, default: () => [] }
  },
  emits: ["update:model-value", "toggle", "set-ref"],
  setup(e, { emit: n }) {
    const a = e, { transitionName: t, showTransition: s } = Kt(a.transitions), m = H(null);
    return Ge(() => n("set-ref", m)), (g, C) => (p(), I(ye, null, [
      ae("button", {
        type: "button",
        class: "dp__btn dp__month_year_select",
        onClick: C[0] || (C[0] = (E) => g.$emit("toggle")),
        onKeydown: [
          C[1] || (C[1] = ie(He((E) => g.$emit("toggle"), ["prevent"]), ["enter"])),
          C[2] || (C[2] = ie(He((E) => g.$emit("toggle"), ["prevent"]), ["space"]))
        ],
        "aria-label": e.ariaLabel,
        tabindex: "0",
        ref_key: "elRef",
        ref: m
      }, [
        G(g.$slots, "default")
      ], 40, Ll),
      kt(Mt, {
        name: M(t)(e.showSelectionGrid),
        css: M(s)
      }, {
        default: ce(() => [
          e.showSelectionGrid ? (p(), me(_t, Ce({ key: 0 }, {
            modelValue: e.modelValue,
            items: e.items,
            disabledValues: e.disabledValues,
            minValue: e.minValue,
            maxValue: e.maxValue,
            escClose: e.escClose,
            type: e.type,
            arrowNavigation: e.arrowNavigation,
            textInput: e.textInput,
            autoApply: e.autoApply,
            ariaLabels: e.ariaLabels,
            hideNavigation: e.hideNavigation
          }, {
            "header-refs": [],
            "onUpdate:modelValue": C[3] || (C[3] = (E) => g.$emit("update:model-value", E)),
            onToggle: C[4] || (C[4] = (E) => g.$emit("toggle"))
          }), Ue({
            "button-icon": ce(() => [
              g.$slots["calendar-icon"] ? G(g.$slots, "calendar-icon", { key: 0 }) : A("", !0),
              g.$slots["calendar-icon"] ? A("", !0) : (p(), me(M(jt), { key: 1 }))
            ]),
            _: 2
          }, [
            g.$slots[e.slotName] ? {
              name: "item",
              fn: ce(({ item: E }) => [
                G(g.$slots, e.slotName, { item: E })
              ]),
              key: "0"
            } : void 0,
            g.$slots[e.overlaySlot] ? {
              name: "overlay",
              fn: ce(() => [
                G(g.$slots, e.overlaySlot)
              ]),
              key: "1"
            } : void 0,
            g.$slots[`${e.overlaySlot}-header`] ? {
              name: "header",
              fn: ce(() => [
                G(g.$slots, `${e.overlaySlot}-header`)
              ]),
              key: "2"
            } : void 0
          ]), 1040)) : A("", !0)
        ]),
        _: 3
      }, 8, ["name", "css"])
    ], 64));
  }
}), Fl = { class: "dp__month_year_row" }, Ul = { class: "dp__month_picker_header" }, Wl = ["aria-label"], Hl = ["aria-label"], xl = ["aria-label"], zl = /* @__PURE__ */ Xe({
  __name: "MonthYearPicker",
  props: {
    month: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    instance: { type: Number, default: 0 },
    years: { type: Array, default: () => [] },
    months: { type: Array, default: () => [] },
    internalModelValue: { type: [Date, Array], default: null },
    ...ft
  },
  emits: ["update-month-year", "month-year-select", "mount", "reset-flow", "overlay-closed"],
  setup(e, { expose: n, emit: a }) {
    const t = e, { defaults: s } = xe(t), { transitionName: m, showTransition: g } = Kt(s.value.transitions), { buildMatrix: C } = ct(), { handleMonthYearChange: E, isDisabled: S, updateMonthYear: F } = fl(t, a), P = H(!1), c = H(!1), k = H([null, null, null, null]), Q = H(null), j = H(null), x = H(null);
    Ge(() => {
      a("mount");
    });
    const B = (i) => ({
      get: () => t[i],
      set: (r) => {
        const Y = i === "month" ? "year" : "month";
        a("update-month-year", { [i]: r, [Y]: t[Y] }), a("month-year-select", i === "year"), i === "month" ? u(!0) : $(!0);
      }
    }), U = L(B("month")), O = L(B("year")), q = (i) => {
      const r = ke(T(i));
      return t.year === r;
    }, K = L(() => t.monthPicker ? Array.isArray(t.disabledDates) ? t.disabledDates.map((i) => T(i)).filter((i) => q(i)).map((i) => he(i)) : [] : []), ne = L(() => (i) => {
      const r = i === "month";
      return {
        showSelectionGrid: (r ? P : c).value,
        items: (r ? _ : w).value,
        disabledValues: s.value.filters[r ? "months" : "years"].concat(K.value),
        minValue: (r ? ve : de).value,
        maxValue: (r ? V : ue).value,
        headerRefs: r && t.monthPicker ? [Q.value, j.value, x.value] : [],
        escClose: t.escClose,
        transitions: s.value.transitions,
        ariaLabels: s.value.ariaLabels,
        textInput: t.textInput,
        autoApply: t.autoApply,
        arrowNavigation: t.arrowNavigation,
        hideNavigation: t.hideNavigation
      };
    }), se = L(() => (i) => ({
      month: t.month,
      year: t.year,
      items: i === "month" ? t.months : t.years,
      instance: t.instance,
      updateMonthYear: F,
      toggle: i === "month" ? u : $
    })), de = L(() => t.minDate ? ke(T(t.minDate)) : null), ue = L(() => t.maxDate ? ke(T(t.maxDate)) : null), ve = L(() => {
      if (t.minDate && de.value) {
        if (de.value > t.year)
          return 12;
        if (de.value === t.year)
          return he(T(t.minDate));
      }
      return null;
    }), V = L(() => t.maxDate && ue.value ? ue.value < t.year ? -1 : ue.value === t.year ? he(T(t.maxDate)) : null : null), D = L(() => (t.range || t.multiDates) && t.internalModelValue && (t.monthPicker || t.yearPicker) ? t.internalModelValue : []), d = (i) => {
      const r = [], Y = (le) => le;
      for (let le = 0; le < i.length; le += 3) {
        const Ae = [i[le], i[le + 1], i[le + 2]];
        r.push(Y(Ae));
      }
      return r;
    }, N = L(() => {
      const i = t.months.find((r) => r.value === t.month);
      return i || { text: "", value: 0 };
    }), _ = L(() => d(t.months)), w = L(() => d(t.years)), y = L(() => s.value.multiCalendars ? t.multiCalendarsSolo ? !0 : t.instance === 0 : !0), z = L(() => s.value.multiCalendars ? t.multiCalendarsSolo ? !0 : t.instance === s.value.multiCalendars - 1 : !0), f = (i, r) => {
      r !== void 0 ? i.value = r : i.value = !i.value;
    }, u = (i = !1, r) => {
      l(i), f(P, r), P.value || a("overlay-closed");
    }, $ = (i = !1, r) => {
      l(i), f(c, r), c.value || a("overlay-closed");
    }, l = (i) => {
      i || a("reset-flow");
    }, v = (i = !1) => {
      S.value(i) || a("update-month-year", {
        year: i ? t.year + 1 : t.year - 1,
        month: t.month,
        fromNav: !0
      });
    }, R = (i, r) => {
      t.arrowNavigation && (k.value[r] = Te(i), C(k.value, "monthYear"));
    };
    return n({
      toggleMonthPicker: u,
      toggleYearPicker: $,
      handleMonthYearChange: E
    }), (i, r) => {
      var Y, le, Ae, Se, be;
      return p(), I("div", Fl, [
        i.$slots["month-year"] ? G(i.$slots, "month-year", Be(Ce({ key: 0 }, { month: e.month, year: e.year, months: e.months, years: e.years, updateMonthYear: M(F), handleMonthYearChange: M(E), instance: e.instance }))) : (p(), I(ye, { key: 1 }, [
          !i.monthPicker && !i.yearPicker ? (p(), I(ye, { key: 0 }, [
            y.value && !i.vertical ? (p(), me(sn, {
              key: 0,
              "aria-label": (Y = M(s).ariaLabels) == null ? void 0 : Y.prevMonth,
              disabled: M(S)(!1),
              onActivate: r[0] || (r[0] = (ee) => M(E)(!1)),
              onSetRef: r[1] || (r[1] = (ee) => R(ee, 0))
            }, {
              default: ce(() => [
                i.$slots["arrow-left"] ? G(i.$slots, "arrow-left", { key: 0 }) : A("", !0),
                i.$slots["arrow-left"] ? A("", !0) : (p(), me(M(Pn), { key: 1 }))
              ]),
              _: 3
            }, 8, ["aria-label", "disabled"])) : A("", !0),
            ae("div", {
              class: ge(["dp__month_year_wrap", {
                dp__year_disable_select: t.disableYearSelect
              }])
            }, [
              kt(Hn, Ce({
                type: "month",
                "slot-name": "month-overlay-val",
                "overlay-slot": "overlay-month",
                "aria-label": (le = M(s).ariaLabels) == null ? void 0 : le.openMonthsOverlay,
                modelValue: U.value,
                "onUpdate:modelValue": r[2] || (r[2] = (ee) => U.value = ee)
              }, ne.value("month"), {
                onToggle: u,
                onSetRef: r[3] || (r[3] = (ee) => R(ee, 1))
              }), Ue({
                default: ce(() => [
                  i.$slots.month ? G(i.$slots, "month", Be(Ce({ key: 0 }, N.value))) : A("", !0),
                  i.$slots.month ? A("", !0) : (p(), I(ye, { key: 1 }, [
                    tt(Ye(N.value.text), 1)
                  ], 64))
                ]),
                _: 2
              }, [
                i.$slots["calendar-icon"] ? {
                  name: "calendar-icon",
                  fn: ce(() => [
                    G(i.$slots, "calendar-icon")
                  ]),
                  key: "0"
                } : void 0,
                i.$slots["month-overlay-value"] ? {
                  name: "month-overlay-val",
                  fn: ce(({ item: ee }) => [
                    G(i.$slots, "month-overlay-value", {
                      text: ee.text,
                      value: ee.value
                    })
                  ]),
                  key: "1"
                } : void 0,
                i.$slots["month-overlay"] ? {
                  name: "overlay-month",
                  fn: ce(() => [
                    G(i.$slots, "month-overlay", Be(qe(se.value("month"))))
                  ]),
                  key: "2"
                } : void 0,
                i.$slots["month-overlay-header"] ? {
                  name: "overlay-month-header",
                  fn: ce(() => [
                    G(i.$slots, "month-overlay-header", { toggle: u })
                  ]),
                  key: "3"
                } : void 0
              ]), 1040, ["aria-label", "modelValue"]),
              t.disableYearSelect ? A("", !0) : (p(), me(Hn, Ce({
                key: 0,
                type: "year",
                "slot-name": "year-overlay-val",
                "overlay-slot": "overlay-year",
                "aria-label": (Ae = M(s).ariaLabels) == null ? void 0 : Ae.openYearsOverlay,
                modelValue: O.value,
                "onUpdate:modelValue": r[4] || (r[4] = (ee) => O.value = ee)
              }, ne.value("year"), {
                onToggle: $,
                onSetRef: r[5] || (r[5] = (ee) => R(ee, 2))
              }), Ue({
                default: ce(() => [
                  i.$slots.year ? G(i.$slots, "year", {
                    key: 0,
                    year: e.year
                  }) : A("", !0),
                  i.$slots.year ? A("", !0) : (p(), I(ye, { key: 1 }, [
                    tt(Ye(e.year), 1)
                  ], 64))
                ]),
                _: 2
              }, [
                i.$slots["calendar-icon"] ? {
                  name: "calendar-icon",
                  fn: ce(() => [
                    G(i.$slots, "calendar-icon")
                  ]),
                  key: "0"
                } : void 0,
                i.$slots["year-overlay-value"] ? {
                  name: "year-overlay-val",
                  fn: ce(({ item: ee }) => [
                    G(i.$slots, "year-overlay-value", {
                      text: ee.text,
                      value: ee.value
                    })
                  ]),
                  key: "1"
                } : void 0,
                i.$slots["year-overlay"] ? {
                  name: "overlay-year",
                  fn: ce(() => [
                    G(i.$slots, "year-overlay", Be(qe(se.value("year"))))
                  ]),
                  key: "2"
                } : void 0,
                i.$slots["year-overlay-header"] ? {
                  name: "overlay-year-header",
                  fn: ce(() => [
                    G(i.$slots, "year-overlay-header", { toggle: $ })
                  ]),
                  key: "3"
                } : void 0
              ]), 1040, ["aria-label", "modelValue"]))
            ], 2),
            y.value && i.vertical ? (p(), me(sn, {
              key: 1,
              "aria-label": (Se = M(s).ariaLabels) == null ? void 0 : Se.prevMonth,
              disabled: M(S)(!1),
              onActivate: r[6] || (r[6] = (ee) => M(E)(!1))
            }, {
              default: ce(() => [
                i.$slots["arrow-up"] ? G(i.$slots, "arrow-up", { key: 0 }) : A("", !0),
                i.$slots["arrow-up"] ? A("", !0) : (p(), me(M(qn), { key: 1 }))
              ]),
              _: 3
            }, 8, ["aria-label", "disabled"])) : A("", !0),
            z.value ? (p(), me(sn, {
              key: 2,
              ref: "rightIcon",
              disabled: M(S)(!0),
              "aria-label": (be = M(s).ariaLabels) == null ? void 0 : be.nextMonth,
              onActivate: r[7] || (r[7] = (ee) => M(E)(!0)),
              onSetRef: r[8] || (r[8] = (ee) => R(ee, 3))
            }, {
              default: ce(() => [
                i.$slots[i.vertical ? "arrow-down" : "arrow-right"] ? G(i.$slots, i.vertical ? "arrow-down" : "arrow-right", { key: 0 }) : A("", !0),
                i.$slots[i.vertical ? "arrow-down" : "arrow-right"] ? A("", !0) : (p(), me(xn(i.vertical ? M(Xn) : M(Cn)), { key: 1 }))
              ]),
              _: 3
            }, 8, ["disabled", "aria-label"])) : A("", !0)
          ], 64)) : A("", !0),
          i.monthPicker ? (p(), me(_t, Ce({ key: 1 }, ne.value("month"), {
            "skip-active": i.range,
            year: e.year,
            "multi-model-value": D.value,
            "month-picker": "",
            modelValue: U.value,
            "onUpdate:modelValue": r[17] || (r[17] = (ee) => U.value = ee),
            onToggle: u,
            onSelected: r[18] || (r[18] = (ee) => i.$emit("overlay-closed"))
          }), Ue({
            header: ce(() => {
              var ee, We, Ie;
              return [
                ae("div", Ul, [
                  ae("div", {
                    class: "dp__month_year_col_nav",
                    tabindex: "0",
                    ref_key: "mpPrevIconRef",
                    ref: Q,
                    onClick: r[9] || (r[9] = (Re) => v(!1)),
                    onKeydown: r[10] || (r[10] = ie((Re) => v(!1), ["enter"]))
                  }, [
                    ae("div", {
                      class: ge(["dp__inner_nav", { dp__inner_nav_disabled: M(S)(!1) }]),
                      role: "button",
                      "aria-label": (ee = M(s).ariaLabels) == null ? void 0 : ee.prevMonth
                    }, [
                      i.$slots["arrow-left"] ? G(i.$slots, "arrow-left", { key: 0 }) : A("", !0),
                      i.$slots["arrow-left"] ? A("", !0) : (p(), me(M(Pn), { key: 1 }))
                    ], 10, Wl)
                  ], 544),
                  ae("div", {
                    class: "dp__pointer",
                    role: "button",
                    ref_key: "mpYearButtonRef",
                    ref: j,
                    "aria-label": (We = M(s).ariaLabels) == null ? void 0 : We.openYearsOverlay,
                    tabindex: "0",
                    onClick: r[11] || (r[11] = () => $(!1)),
                    onKeydown: r[12] || (r[12] = ie(() => $(!1), ["enter"]))
                  }, [
                    i.$slots.year ? G(i.$slots, "year", {
                      key: 0,
                      year: e.year
                    }) : A("", !0),
                    i.$slots.year ? A("", !0) : (p(), I(ye, { key: 1 }, [
                      tt(Ye(e.year), 1)
                    ], 64))
                  ], 40, Hl),
                  ae("div", {
                    class: "dp__month_year_col_nav",
                    tabindex: "0",
                    ref_key: "mpNextIconRef",
                    ref: x,
                    onClick: r[13] || (r[13] = (Re) => v(!0)),
                    onKeydown: r[14] || (r[14] = ie((Re) => v(!0), ["enter"]))
                  }, [
                    ae("div", {
                      class: ge(["dp__inner_nav", { dp__inner_nav_disabled: M(S)(!0) }]),
                      role: "button",
                      "aria-label": (Ie = M(s).ariaLabels) == null ? void 0 : Ie.nextMonth
                    }, [
                      i.$slots["arrow-right"] ? G(i.$slots, "arrow-right", { key: 0 }) : A("", !0),
                      i.$slots["arrow-right"] ? A("", !0) : (p(), me(M(Cn), { key: 1 }))
                    ], 10, xl)
                  ], 544)
                ]),
                kt(Mt, {
                  name: M(m)(c.value),
                  css: M(g)
                }, {
                  default: ce(() => [
                    c.value ? (p(), me(_t, Ce({ key: 0 }, ne.value("year"), {
                      modelValue: O.value,
                      "onUpdate:modelValue": r[15] || (r[15] = (Re) => O.value = Re),
                      onToggle: $,
                      onSelected: r[16] || (r[16] = (Re) => i.$emit("overlay-closed"))
                    }), Ue({
                      "button-icon": ce(() => [
                        i.$slots["calendar-icon"] ? G(i.$slots, "calendar-icon", { key: 0 }) : A("", !0),
                        i.$slots["calendar-icon"] ? A("", !0) : (p(), me(M(jt), { key: 1 }))
                      ]),
                      _: 2
                    }, [
                      i.$slots["year-overlay-value"] ? {
                        name: "item",
                        fn: ce(({ item: Re }) => [
                          G(i.$slots, "year-overlay-value", {
                            text: Re.text,
                            value: Re.value
                          })
                        ]),
                        key: "0"
                      } : void 0
                    ]), 1040, ["modelValue"])) : A("", !0)
                  ]),
                  _: 3
                }, 8, ["name", "css"])
              ];
            }),
            _: 2
          }, [
            i.$slots["month-overlay-value"] ? {
              name: "item",
              fn: ce(({ item: ee }) => [
                G(i.$slots, "month-overlay-value", {
                  text: ee.text,
                  value: ee.value
                })
              ]),
              key: "0"
            } : void 0
          ]), 1040, ["skip-active", "year", "multi-model-value", "modelValue"])) : A("", !0),
          i.yearPicker ? (p(), me(_t, Ce({ key: 2 }, ne.value("year"), {
            modelValue: O.value,
            "onUpdate:modelValue": r[19] || (r[19] = (ee) => O.value = ee),
            "multi-model-value": D.value,
            "skip-active": i.range,
            "skip-button-ref": "",
            "year-picker": "",
            onToggle: $,
            onSelected: r[20] || (r[20] = (ee) => i.$emit("overlay-closed"))
          }), Ue({ _: 2 }, [
            i.$slots["year-overlay-value"] ? {
              name: "item",
              fn: ce(({ item: ee }) => [
                G(i.$slots, "year-overlay-value", {
                  text: ee.text,
                  value: ee.value
                })
              ]),
              key: "0"
            } : void 0
          ]), 1040, ["modelValue", "multi-model-value", "skip-active"])) : A("", !0)
        ], 64))
      ]);
    };
  }
}), jl = {
  key: 0,
  class: "dp__time_input"
}, Kl = ["aria-label", "onKeydown", "onClick"], Gl = ["aria-label", "onKeydown", "onClick"], Zl = ["aria-label", "onKeydown", "onClick"], ql = { key: 0 }, Xl = ["aria-label", "onKeydown"], Jl = /* @__PURE__ */ Xe({
  __name: "TimeInput",
  props: {
    hours: { type: Number, default: 0 },
    minutes: { type: Number, default: 0 },
    seconds: { type: Number, default: 0 },
    closeTimePickerBtn: { type: Object, default: null },
    order: { type: Number, default: 0 },
    ...ft
  },
  emits: [
    "set-hours",
    "set-minutes",
    "update:hours",
    "update:minutes",
    "update:seconds",
    "reset-flow",
    "mounted",
    "overlay-closed",
    "am-pm-change"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, { setTimePickerElements: s, setTimePickerBackRef: m } = ct(), { defaults: g } = xe(t), { transitionName: C, showTransition: E } = Kt(g.value.transitions), S = $t({
      hours: !1,
      minutes: !1,
      seconds: !1
    }), F = H("AM"), P = H(null), c = H([]);
    Ge(() => {
      a("mounted");
    });
    const k = (f) => _e(/* @__PURE__ */ new Date(), {
      hours: f.hours,
      minutes: f.minutes,
      seconds: t.enableSeconds ? f.seconds : 0,
      milliseconds: 0
    }), Q = L(() => ({ hours: t.hours, minutes: t.minutes, seconds: t.seconds })), j = L(() => (f) => !de(+t[f] + +t[`${f}Increment`], f)), x = L(() => (f) => !de(+t[f] - +t[`${f}Increment`], f)), B = (f, u) => Gn(_e(T(), f), u), U = (f, u) => ka(_e(T(), f), u), O = L(
      () => ({
        dp__time_col: !0,
        dp__time_col_reg: !t.enableSeconds && t.is24,
        dp__time_col_reg_with_button: !t.enableSeconds && !t.is24,
        dp__time_col_sec: t.enableSeconds && t.is24,
        dp__time_col_sec_with_button: t.enableSeconds && !t.is24
      })
    ), q = L(() => {
      const f = [{ type: "hours" }, { type: "", separator: !0 }, { type: "minutes" }];
      return t.enableSeconds ? f.concat([{ type: "", separator: !0 }, { type: "seconds" }]) : f;
    }), K = L(() => q.value.filter((f) => !f.separator)), ne = L(() => (f) => {
      if (f === "hours") {
        const u = N(+t.hours);
        return { text: u < 10 ? `0${u}` : `${u}`, value: u };
      }
      return { text: t[f] < 10 ? `0${t[f]}` : `${t[f]}`, value: t[f] };
    }), se = (f) => {
      const u = t.is24 ? 24 : 12, $ = f === "hours" ? u : 60, l = +t[`${f}GridIncrement`], v = f === "hours" && !t.is24 ? l : 0, R = [];
      for (let i = v; i < $; i += l)
        R.push({ value: i, text: i < 10 ? `0${i}` : `${i}` });
      return f === "hours" && !t.is24 && R.push({ value: 0, text: "12" }), qa(R);
    }, de = (f, u) => {
      const $ = t.minTime ? k(Jt(t.minTime)) : null, l = t.maxTime ? k(Jt(t.maxTime)) : null, v = k(Jt(Q.value, u, f));
      return $ && l ? (Ot(v, l) || yt(v, l)) && (It(v, $) || yt(v, $)) : $ ? It(v, $) || yt(v, $) : l ? Ot(v, l) || yt(v, l) : !0;
    }, ue = L(() => (f) => se(f).flat().filter(($) => $ || ($ == null ? void 0 : $.value) === 0).map(($) => $.value).filter(($) => !de($, f))), ve = (f) => t[`no${f[0].toUpperCase() + f.slice(1)}Overlay`], V = (f) => {
      ve(f) || (S[f] = !S[f], S[f] || a("overlay-closed"));
    }, D = (f) => f === "hours" ? lt : f === "minutes" ? rt : Dt, d = (f, u = !0) => {
      const $ = u ? B : U, l = u ? +t[`${f}Increment`] : -+t[`${f}Increment`];
      de(+t[f] + l, f) && a(
        `update:${f}`,
        D(f)($({ [f]: +t[f] }, { [f]: +t[`${f}Increment`] }))
      );
    }, N = (f) => t.is24 ? f : (f >= 12 ? F.value = "PM" : F.value = "AM", el(f)), _ = () => {
      F.value === "PM" ? (F.value = "AM", a("update:hours", t.hours - 12)) : (F.value = "PM", a("update:hours", t.hours + 12)), a("am-pm-change", F.value);
    }, w = (f) => {
      S[f] = !0;
    }, y = (f, u, $) => {
      if (f && t.arrowNavigation) {
        Array.isArray(c.value[u]) ? c.value[u][$] = f : c.value[u] = [f];
        const l = c.value.reduce(
          (v, R) => R.map((i, r) => [...v[r] || [], R[r]]),
          []
        );
        m(t.closeTimePickerBtn), P.value && (l[1] = l[1].concat(P.value)), s(l, t.order);
      }
    }, z = (f, u) => f === "hours" && !t.is24 ? a(`update:${f}`, F.value === "PM" ? u + 12 : u) : a(`update:${f}`, u);
    return n({ openChildCmp: w }), (f, u) => {
      var $;
      return f.disabled ? A("", !0) : (p(), I("div", jl, [
        (p(!0), I(ye, null, Ne(q.value, (l, v) => {
          var R, i, r;
          return p(), I("div", {
            key: v,
            class: ge(O.value)
          }, [
            l.separator ? (p(), I(ye, { key: 0 }, [
              tt(" : ")
            ], 64)) : (p(), I(ye, { key: 1 }, [
              ae("button", {
                type: "button",
                class: ge({
                  dp__btn: !0,
                  dp__inc_dec_button: !0,
                  dp__inc_dec_button_disabled: j.value(l.type)
                }),
                "aria-label": (R = M(g).ariaLabels) == null ? void 0 : R.incrementValue(l.type),
                tabindex: "0",
                onKeydown: [
                  ie((Y) => d(l.type), ["enter"]),
                  ie((Y) => d(l.type), ["space"])
                ],
                onClick: (Y) => d(l.type),
                ref_for: !0,
                ref: (Y) => y(Y, v, 0)
              }, [
                f.$slots["arrow-up"] ? G(f.$slots, "arrow-up", { key: 0 }) : A("", !0),
                f.$slots["arrow-up"] ? A("", !0) : (p(), me(M(qn), { key: 1 }))
              ], 42, Kl),
              ae("button", {
                type: "button",
                "aria-label": (i = M(g).ariaLabels) == null ? void 0 : i.openTpOverlay(l.type),
                class: ge(["dp__btn", ve(l.type) ? "" : "dp__time_display"]),
                tabindex: "0",
                onKeydown: [
                  ie((Y) => V(l.type), ["enter"]),
                  ie((Y) => V(l.type), ["space"])
                ],
                onClick: (Y) => V(l.type),
                ref_for: !0,
                ref: (Y) => y(Y, v, 1)
              }, [
                f.$slots[l.type] ? G(f.$slots, l.type, {
                  key: 0,
                  text: ne.value(l.type).text,
                  value: ne.value(l.type).value
                }) : A("", !0),
                f.$slots[l.type] ? A("", !0) : (p(), I(ye, { key: 1 }, [
                  tt(Ye(ne.value(l.type).text), 1)
                ], 64))
              ], 42, Gl),
              ae("button", {
                type: "button",
                class: ge({
                  dp__btn: !0,
                  dp__inc_dec_button: !0,
                  dp__inc_dec_button_disabled: x.value(l.type)
                }),
                "aria-label": (r = M(g).ariaLabels) == null ? void 0 : r.decrementValue(l.type),
                tabindex: "0",
                onKeydown: [
                  ie((Y) => d(l.type, !1), ["enter"]),
                  ie((Y) => d(l.type, !1), ["space"])
                ],
                onClick: (Y) => d(l.type, !1),
                ref_for: !0,
                ref: (Y) => y(Y, v, 2)
              }, [
                f.$slots["arrow-down"] ? G(f.$slots, "arrow-down", { key: 0 }) : A("", !0),
                f.$slots["arrow-down"] ? A("", !0) : (p(), me(M(Xn), { key: 1 }))
              ], 42, Zl)
            ], 64))
          ], 2);
        }), 128)),
        f.is24 ? A("", !0) : (p(), I("div", ql, [
          f.$slots["am-pm-button"] ? G(f.$slots, "am-pm-button", {
            key: 0,
            toggle: _,
            value: F.value
          }) : A("", !0),
          f.$slots["am-pm-button"] ? A("", !0) : (p(), I("button", {
            key: 1,
            ref_key: "amPmButton",
            ref: P,
            type: "button",
            class: "dp__pm_am_button",
            role: "button",
            "aria-label": ($ = M(g).ariaLabels) == null ? void 0 : $.amPmButton,
            tabindex: "0",
            onClick: _,
            onKeydown: [
              ie(He(_, ["prevent"]), ["enter"]),
              ie(He(_, ["prevent"]), ["space"])
            ]
          }, Ye(F.value), 41, Xl))
        ])),
        (p(!0), I(ye, null, Ne(K.value, (l, v) => (p(), me(Mt, {
          key: v,
          name: M(C)(S[l.type]),
          css: M(E)
        }, {
          default: ce(() => [
            S[l.type] ? (p(), me(_t, {
              key: 0,
              items: se(l.type),
              "disabled-values": M(g).filters.times[l.type].concat(ue.value(l.type)),
              "esc-close": f.escClose,
              "aria-labels": M(g).ariaLabels,
              "hide-navigation": f.hideNavigation,
              "onUpdate:modelValue": (R) => z(l.type, R),
              onSelected: (R) => V(l.type),
              onToggle: (R) => V(l.type),
              onResetFlow: u[0] || (u[0] = (R) => f.$emit("reset-flow")),
              type: l.type
            }, Ue({
              "button-icon": ce(() => [
                f.$slots["clock-icon"] ? G(f.$slots, "clock-icon", { key: 0 }) : A("", !0),
                f.$slots["clock-icon"] ? A("", !0) : (p(), me(M(Zn), { key: 1 }))
              ]),
              _: 2
            }, [
              f.$slots[`${l.type}-overlay-value`] ? {
                name: "item",
                fn: ce(({ item: R }) => [
                  G(f.$slots, `${l.type}-overlay-value`, {
                    text: R.text,
                    value: R.value
                  })
                ]),
                key: "0"
              } : void 0
            ]), 1032, ["items", "disabled-values", "esc-close", "aria-labels", "hide-navigation", "onUpdate:modelValue", "onSelected", "onToggle", "type"])) : A("", !0)
          ]),
          _: 2
        }, 1032, ["name", "css"]))), 128))
      ]));
    };
  }
}), Ql = ["aria-label"], er = { class: "dp__overlay_container dp__container_flex dp__time_picker_overlay_container" }, tr = {
  key: 1,
  class: "dp__overlay_row dp__flex_row"
}, nr = ["aria-label"], ar = /* @__PURE__ */ Xe({
  __name: "TimePicker",
  props: {
    hours: { type: [Number, Array], default: 0 },
    minutes: { type: [Number, Array], default: 0 },
    seconds: { type: [Number, Array], default: 0 },
    internalModelValue: { type: [Date, Array], default: null },
    ...ft
  },
  emits: [
    "update:hours",
    "update:minutes",
    "update:seconds",
    "mount",
    "reset-flow",
    "overlay-opened",
    "overlay-closed",
    "am-pm-change"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, { buildMatrix: s, setTimePicker: m } = ct(), g = pn(), { hideNavigationButtons: C, defaults: E } = xe(t), { transitionName: S, showTransition: F } = Kt(E.value.transitions), P = H(null), c = H(null), k = H([]), Q = H(null);
    Ge(() => {
      a("mount"), !t.timePicker && t.arrowNavigation ? s([Te(P.value)], "time") : m(!0, t.timePicker);
    });
    const j = L(() => t.range && t.modelAuto ? aa(t.internalModelValue) : !0), x = H(!1), B = (V) => ({
      hours: Array.isArray(t.hours) ? t.hours[V] : t.hours,
      minutes: Array.isArray(t.minutes) ? t.minutes[V] : t.minutes,
      seconds: Array.isArray(t.seconds) ? t.seconds[V] : t.seconds
    }), U = L(() => {
      const V = [];
      if (t.range)
        for (let D = 0; D < 2; D++)
          V.push(B(D));
      else
        V.push(B(0));
      return V;
    }), O = (V, D = !1, d = "") => {
      D || a("reset-flow"), x.value = V, a(V ? "overlay-opened" : "overlay-closed"), t.arrowNavigation && m(V), ot(() => {
        d !== "" && k.value[0] && k.value[0].openChildCmp(d);
      });
    }, q = L(() => ({
      dp__btn: !0,
      dp__button: !0,
      dp__button_bottom: t.autoApply && !t.keepActionRow
    })), K = pt(g, "timePicker"), ne = (V, D, d) => t.range ? D === 0 ? [V, U.value[1][d]] : [U.value[0][d], V] : V, se = (V) => {
      a("update:hours", V);
    }, de = (V) => {
      a("update:minutes", V);
    }, ue = (V) => {
      a("update:seconds", V);
    }, ve = () => {
      if (Q.value) {
        const V = nl(Q.value);
        V && V.focus({ preventScroll: !0 });
      }
    };
    return n({ toggleTimePicker: O }), (V, D) => {
      var d;
      return p(), I("div", null, [
        V.timePicker ? A("", !0) : Ft((p(), I("button", {
          key: 0,
          type: "button",
          class: ge(q.value),
          "aria-label": (d = M(E).ariaLabels) == null ? void 0 : d.openTimePicker,
          tabindex: "0",
          ref_key: "openTimePickerBtn",
          ref: P,
          onKeydown: [
            D[0] || (D[0] = ie((N) => O(!0), ["enter"])),
            D[1] || (D[1] = ie((N) => O(!0), ["space"]))
          ],
          onClick: D[2] || (D[2] = (N) => O(!0))
        }, [
          V.$slots["clock-icon"] ? G(V.$slots, "clock-icon", { key: 0 }) : A("", !0),
          V.$slots["clock-icon"] ? A("", !0) : (p(), me(M(Zn), { key: 1 }))
        ], 42, Ql)), [
          [Ut, !M(C)("time")]
        ]),
        kt(Mt, {
          name: M(S)(x.value),
          css: M(F)
        }, {
          default: ce(() => {
            var N;
            return [
              x.value || V.timePicker ? (p(), I("div", {
                key: 0,
                class: "dp__overlay",
                ref_key: "overlayRef",
                ref: Q,
                tabindex: "0"
              }, [
                ae("div", er, [
                  V.$slots["time-picker-overlay"] ? G(V.$slots, "time-picker-overlay", {
                    key: 0,
                    hours: e.hours,
                    minutes: e.minutes,
                    seconds: e.seconds,
                    setHours: se,
                    setMinutes: de,
                    setSeconds: ue
                  }) : A("", !0),
                  V.$slots["time-picker-overlay"] ? A("", !0) : (p(), I("div", tr, [
                    (p(!0), I(ye, null, Ne(U.value, (_, w) => Ft((p(), me(Jl, Ce({ key: w }, {
                      ...V.$props,
                      order: w,
                      hours: _.hours,
                      minutes: _.minutes,
                      seconds: _.seconds,
                      closeTimePickerBtn: c.value,
                      disabled: w === 0 ? V.fixedStart : V.fixedEnd
                    }, {
                      ref_for: !0,
                      ref_key: "timeInputRefs",
                      ref: k,
                      "onUpdate:hours": (y) => se(ne(y, w, "hours")),
                      "onUpdate:minutes": (y) => de(ne(y, w, "minutes")),
                      "onUpdate:seconds": (y) => ue(ne(y, w, "seconds")),
                      onMounted: ve,
                      onOverlayClosed: ve,
                      onAmPmChange: D[3] || (D[3] = (y) => V.$emit("am-pm-change", y))
                    }), Ue({ _: 2 }, [
                      Ne(M(K), (y, z) => ({
                        name: y,
                        fn: ce((f) => [
                          G(V.$slots, y, Be(qe(f)))
                        ])
                      }))
                    ]), 1040, ["onUpdate:hours", "onUpdate:minutes", "onUpdate:seconds"])), [
                      [Ut, w === 0 ? !0 : j.value]
                    ])), 128))
                  ])),
                  V.timePicker ? A("", !0) : Ft((p(), I("button", {
                    key: 2,
                    type: "button",
                    ref_key: "closeTimePickerBtn",
                    ref: c,
                    class: ge(q.value),
                    "aria-label": (N = M(E).ariaLabels) == null ? void 0 : N.closeTimePicker,
                    tabindex: "0",
                    onKeydown: [
                      D[4] || (D[4] = ie((_) => O(!1), ["enter"])),
                      D[5] || (D[5] = ie((_) => O(!1), ["space"]))
                    ],
                    onClick: D[6] || (D[6] = (_) => O(!1))
                  }, [
                    V.$slots["calendar-icon"] ? G(V.$slots, "calendar-icon", { key: 0 }) : A("", !0),
                    V.$slots["calendar-icon"] ? A("", !0) : (p(), me(M(jt), { key: 1 }))
                  ], 42, nr)), [
                    [Ut, !M(C)("time")]
                  ])
                ])
              ], 512)) : A("", !0)
            ];
          }),
          _: 3
        }, 8, ["name", "css"])
      ]);
    };
  }
}), lr = (e, n) => {
  const { isDisabled: a, matchDate: t, getWeekFromDate: s, defaults: m } = xe(n), g = H(null), C = H(T()), E = (u) => {
    !u.current && n.hideOffsetDates || (g.value = u.value);
  }, S = () => {
    g.value = null;
  }, F = (u) => Array.isArray(e.value) && n.range && e.value[0] && g.value ? u ? Fe(g.value, e.value[0]) : Ve(g.value, e.value[0]) : !0, P = (u, $) => {
    const l = () => e.value ? $ ? e.value[0] || null : e.value[1] : null, v = e.value && Array.isArray(e.value) ? l() : null;
    return pe(T(u.value), v);
  }, c = (u) => {
    const $ = Array.isArray(e.value) ? e.value[0] : null;
    return u ? !Ve(g.value || null, $) : !0;
  }, k = (u, $ = !0) => (n.range || n.weekPicker) && Array.isArray(e.value) && e.value.length === 2 ? n.hideOffsetDates && !u.current ? !1 : pe(T(u.value), e.value[$ ? 0 : 1]) : n.range ? P(u, $) && c($) || pe(u.value, Array.isArray(e.value) ? e.value[0] : null) && F($) : !1, Q = (u, $, l) => Array.isArray(e.value) && e.value[0] && e.value.length === 1 ? u ? !1 : l ? Fe(e.value[0], $.value) : Ve(e.value[0], $.value) : !1, j = (u) => !e.value || n.hideOffsetDates && !u.current ? !1 : n.range ? n.modelAuto && Array.isArray(e.value) ? pe(u.value, e.value[0] ? e.value[0] : C.value) : !1 : n.multiDates && Array.isArray(e.value) ? e.value.some(($) => pe($, u.value)) : pe(u.value, e.value ? e.value : C.value), x = (u) => {
    if (n.autoRange || n.weekPicker) {
      if (g.value) {
        if (n.hideOffsetDates && !u.current)
          return !1;
        const $ = gt(g.value, +n.autoRange), l = s(T(g.value));
        return n.weekPicker ? pe(l[1], T(u.value)) : pe($, T(u.value));
      }
      return !1;
    }
    return !1;
  }, B = (u) => {
    if (n.autoRange || n.weekPicker) {
      if (g.value) {
        const $ = gt(g.value, +n.autoRange);
        if (n.hideOffsetDates && !u.current)
          return !1;
        const l = s(T(g.value));
        return n.weekPicker ? Fe(u.value, l[0]) && Ve(u.value, l[1]) : Fe(u.value, g.value) && Ve(u.value, $);
      }
      return !1;
    }
    return !1;
  }, U = (u) => {
    if (n.autoRange || n.weekPicker) {
      if (g.value) {
        if (n.hideOffsetDates && !u.current)
          return !1;
        const $ = s(T(g.value));
        return n.weekPicker ? pe($[0], u.value) : pe(g.value, u.value);
      }
      return !1;
    }
    return !1;
  }, O = (u) => Jn(e.value, g.value, u.value), q = () => n.modelAuto && Array.isArray(n.internalModelValue) ? !!n.internalModelValue[0] : !1, K = () => n.modelAuto ? aa(n.internalModelValue) : !0, ne = (u) => {
    if (Array.isArray(e.value) && e.value.length || n.weekPicker)
      return !1;
    const $ = n.range ? !k(u) && !k(u, !1) : !0;
    return !a(u.value) && !j(u) && !(!u.current && n.hideOffsetDates) && $;
  }, se = (u) => n.range ? n.modelAuto ? q() && j(u) : !1 : j(u), de = (u) => {
    var $;
    return n.highlight ? t(
      u.value,
      ($ = n.arrMapValues) != null && $.highlightedDates ? n.arrMapValues.highlightedDates : n.highlight
    ) : !1;
  }, ue = (u) => a(u.value) && n.highlightDisabledDays === !1, ve = (u) => n.highlightWeekDays && n.highlightWeekDays.includes(u.value.getDay()), V = (u) => (n.range || n.weekPicker) && (!(m.value.multiCalendars > 0) || u.current) && K() && !(!u.current && n.hideOffsetDates) && !j(u) ? O(u) : !1, D = (u) => {
    const { isRangeStart: $, isRangeEnd: l } = _(u), v = n.range ? $ || l : !1;
    return {
      dp__cell_offset: !u.current,
      dp__pointer: !n.disabled && !(!u.current && n.hideOffsetDates) && !a(u.value),
      dp__cell_disabled: a(u.value),
      dp__cell_highlight: !ue(u) && (de(u) || ve(u)) && !se(u) && !v,
      dp__cell_highlight_active: !ue(u) && (de(u) || ve(u)) && se(u),
      dp__today: !n.noToday && pe(u.value, C.value) && u.current
    };
  }, d = (u) => ({
    dp__active_date: se(u),
    dp__date_hover: ne(u)
  }), N = (u) => ({
    ...w(u),
    ...y(u),
    dp__range_between_week: V(u) && n.weekPicker
  }), _ = (u) => {
    const $ = m.value.multiCalendars > 0 ? u.current && k(u) && K() : k(u) && K(), l = m.value.multiCalendars > 0 ? u.current && k(u, !1) && K() : k(u, !1) && K();
    return { isRangeStart: $, isRangeEnd: l };
  }, w = (u) => {
    const { isRangeStart: $, isRangeEnd: l } = _(u);
    return {
      dp__range_start: $,
      dp__range_end: l,
      dp__range_between: V(u) && !n.weekPicker,
      dp__date_hover_start: Q(ne(u), u, !0),
      dp__date_hover_end: Q(ne(u), u, !1)
    };
  }, y = (u) => ({
    ...w(u),
    dp__cell_auto_range: B(u),
    dp__cell_auto_range_start: U(u),
    dp__cell_auto_range_end: x(u)
  }), z = (u) => n.range ? n.autoRange ? y(u) : n.modelAuto ? { ...d(u), ...w(u) } : w(u) : n.weekPicker ? N(u) : d(u);
  return {
    setHoverDate: E,
    clearHoverDate: S,
    getDayClassData: (u) => n.hideOffsetDates && !u.current ? {} : {
      ...D(u),
      ...z(u),
      [n.dayClass ? n.dayClass(u.value) : ""]: !0,
      [n.calendarCellClassName]: !!n.calendarCellClassName
    }
  };
}, rr = ["id", "onKeydown"], or = {
  key: 0,
  class: "dp__sidebar_left"
}, sr = {
  key: 1,
  class: "dp__preset_ranges"
}, ur = ["onClick"], ir = {
  key: 2,
  class: "dp__sidebar_right"
}, dr = {
  key: 3,
  class: "dp__action_extra"
}, cr = /* @__PURE__ */ Xe({
  __name: "DatepickerMenu",
  props: {
    openOnTop: { type: Boolean, default: !1 },
    internalModelValue: { type: [Date, Array], default: null },
    arrMapValues: { type: Object, default: () => ({}) },
    ...ft
  },
  emits: [
    "close-picker",
    "select-date",
    "auto-apply",
    "time-update",
    "flow-step",
    "update-month-year",
    "invalid-select",
    "update:internal-model-value",
    "recalculate-position",
    "invalid-fixed-range",
    "tooltip-open",
    "tooltip-close",
    "time-picker-open",
    "time-picker-close",
    "am-pm-change",
    "range-start",
    "range-end"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, s = L(() => {
      const { openOnTop: h, internalModelValue: W, arrMapValues: $e, ...Me } = t;
      return Me;
    }), { setMenuFocused: m, setShiftKey: g, control: C } = Qn(), { getCalendarDays: E, defaults: S } = xe(t), F = pn(), P = H(null), c = $t({
      timePicker: !!(!t.enableTimePicker || t.timePicker || t.monthPicker),
      monthYearInput: !!t.timePicker,
      calendar: !1
    }), k = H([]), Q = H([]), j = H(null), x = H(null), B = H(0), U = H(!1), O = H(0);
    Ge(() => {
      var W;
      U.value = !0, !((W = t.presetRanges) != null && W.length) && !F["left-sidebar"] && !F["right-sidebar"] && (ze(), window.addEventListener("resize", ze));
      const h = Te(x);
      if (h && !t.textInput && !t.inline && (m(!0), ue()), h) {
        const $e = (Me) => {
          t.allowPreventDefault && Me.preventDefault(), Me.stopImmediatePropagation(), Me.stopPropagation();
        };
        h.addEventListener("pointerdown", $e), h.addEventListener("mousedown", $e);
      }
    }), hn(() => {
      window.removeEventListener("resize", ze);
    });
    const { arrowRight: q, arrowLeft: K, arrowDown: ne, arrowUp: se } = ct(), de = (h) => {
      h || h === 0 ? Q.value[h].triggerTransition(
        N.value(h),
        _.value(h)
      ) : Q.value.forEach(
        (W, $e) => W.triggerTransition(N.value($e), _.value($e))
      );
    }, ue = () => {
      const h = Te(x);
      h && h.focus({ preventScroll: !0 });
    }, ve = () => {
      var h;
      (h = t.flow) != null && h.length && O.value !== -1 && (O.value += 1, a("flow-step", O.value), b());
    }, V = () => {
      O.value = -1;
    }, {
      calendars: D,
      modelValue: d,
      month: N,
      year: _,
      time: w,
      updateTime: y,
      updateMonthYear: z,
      selectDate: f,
      getWeekNum: u,
      monthYearSelect: $,
      handleScroll: l,
      handleArrow: v,
      handleSwipe: R,
      getMarker: i,
      selectCurrentDate: r,
      presetDateRange: Y
    } = dl(t, a, ve, de, O), { setHoverDate: le, clearHoverDate: Ae, getDayClassData: Se } = lr(d, t), ee = {
      modelValue: d,
      month: N,
      year: _,
      time: w,
      updateTime: y,
      updateMonthYear: z,
      selectDate: f,
      presetDateRange: Y,
      handleMonthYearChange: (h) => {
        k.value[0] && k.value[0].handleMonthYearChange(h);
      }
    };
    dt(
      D,
      () => {
        t.openOnTop && setTimeout(() => {
          a("recalculate-position");
        }, 0);
      },
      { deep: !0 }
    );
    const We = pt(F, "calendar"), Ie = pt(F, "action"), Re = pt(F, "timePicker"), Ze = pt(F, "monthYear"), wt = L(() => t.openOnTop ? "dp__arrow_bottom" : "dp__arrow_top"), Je = L(() => Ja(t.yearRange, t.reverseYears)), nt = L(() => Qa(t.locale, t.monthNameFormat)), ze = () => {
      const h = Te(P);
      h && (B.value = h.getBoundingClientRect().width);
    }, Z = L(() => (h) => E(N.value(h), _.value(h))), oe = L(
      () => S.value.multiCalendars > 0 ? [...Array(S.value.multiCalendars).keys()] : [0]
    ), re = L(
      () => (h) => h === 1
    ), Tt = L(() => t.monthPicker || t.timePicker || t.yearPicker), vt = L(
      () => ({
        dp__menu_inner: !0,
        dp__flex_display: S.value.multiCalendars > 0
      })
    ), Bt = L(() => ({
      dp__instance_calendar: S.value.multiCalendars > 0
    })), At = L(() => ({
      dp__menu_disabled: t.disabled,
      dp__menu_readonly: t.readonly
    })), Gt = L(
      () => (h) => qt(Z, h)
    ), Zt = L(
      () => ({
        dp__menu: !0,
        dp__menu_index: !t.inline,
        dp__relative: t.inline,
        [t.menuClassName]: !!t.menuClassName
      })
    ), qt = (h, W) => h.value(W).map(($e) => ({
      ...$e,
      days: $e.days.map((Me) => (Me.marker = i(Me), Me.classData = Se(Me), Me))
    })), Yt = (h) => {
      h.stopPropagation(), h.stopImmediatePropagation();
    }, $n = () => {
      t.escClose && a("close-picker");
    }, Mn = (h, W = !1) => {
      f(h, W), t.spaceConfirm && a("select-date");
    }, Vt = (h) => {
      var W;
      (W = t.flow) != null && W.length && (c[h] = !0, Object.keys(c).filter(($e) => !c[$e]).length || b());
    }, o = (h, W, $e, Me, ...et) => {
      if (t.flow[O.value] === h) {
        const J = Me ? W.value[0] : W.value;
        J && J[$e](...et);
      }
    }, b = () => {
      o("month", k, "toggleMonthPicker", !0, !0), o("year", k, "toggleYearPicker", !0, !0), o("calendar", j, "toggleTimePicker", !1, !1, !0), o("time", j, "toggleTimePicker", !1, !0, !0);
      const h = t.flow[O.value];
      (h === "hours" || h === "minutes" || h === "seconds") && o(h, j, "toggleTimePicker", !1, !0, !0, h);
    }, X = (h) => {
      if (t.arrowNavigation) {
        if (h === "up")
          return se();
        if (h === "down")
          return ne();
        if (h === "left")
          return K();
        if (h === "right")
          return q();
      } else
        h === "left" || h === "up" ? v("left", 0, h === "up") : v("right", 0, h === "down");
    }, te = (h) => {
      g(h.shiftKey), !t.disableMonthYearSelect && h.code === "Tab" && h.target.classList.contains("dp__menu") && C.value.shiftKeyInMenu && (h.preventDefault(), h.stopImmediatePropagation(), a("close-picker"));
    }, De = () => {
      ue(), a("time-picker-close");
    }, Qe = (h) => {
      var W, $e, Me, et, J;
      (W = j.value) == null || W.toggleTimePicker(!1, !1), (Me = ($e = k.value) == null ? void 0 : $e[h]) == null || Me.toggleMonthPicker(!1, !1), (J = (et = k.value) == null ? void 0 : et[h]) == null || J.toggleYearPicker(!1, !1);
    };
    return n({
      updateMonthYear: z,
      switchView: (h, W = 0) => {
        var $e, Me, et, J, at;
        return h === "month" ? (Me = ($e = k.value) == null ? void 0 : $e[W]) == null ? void 0 : Me.toggleMonthPicker(!1, !0) : h === "year" ? (J = (et = k.value) == null ? void 0 : et[W]) == null ? void 0 : J.toggleYearPicker(!1, !0) : h === "time" ? (at = j.value) == null ? void 0 : at.toggleTimePicker(!0, !1) : Qe(W);
      }
    }), (h, W) => {
      var $e;
      return p(), me(Mt, {
        appear: "",
        name: ($e = M(S).transitions) == null ? void 0 : $e.menuAppear,
        css: !!h.transitions
      }, {
        default: ce(() => {
          var Me, et;
          return [
            ae("div", {
              id: h.uid ? `dp-menu-${h.uid}` : void 0,
              tabindex: "0",
              ref_key: "dpMenuRef",
              ref: x,
              role: "dialog",
              class: ge(Zt.value),
              onMouseleave: W[14] || (W[14] = //@ts-ignore
              (...J) => M(Ae) && M(Ae)(...J)),
              onClick: Yt,
              onKeydown: [
                ie($n, ["esc"]),
                W[15] || (W[15] = ie(He((J) => X("left"), ["prevent"]), ["left"])),
                W[16] || (W[16] = ie(He((J) => X("up"), ["prevent"]), ["up"])),
                W[17] || (W[17] = ie(He((J) => X("down"), ["prevent"]), ["down"])),
                W[18] || (W[18] = ie(He((J) => X("right"), ["prevent"]), ["right"])),
                te
              ]
            }, [
              (h.disabled || h.readonly) && h.inline ? (p(), I("div", {
                key: 0,
                class: ge(At.value)
              }, null, 2)) : A("", !0),
              !h.inline && !h.teleportCenter ? (p(), I("div", {
                key: 1,
                class: ge(wt.value)
              }, null, 2)) : A("", !0),
              ae("div", {
                class: ge({
                  dp__menu_content_wrapper: ((Me = h.presetRanges) == null ? void 0 : Me.length) || !!h.$slots["left-sidebar"] || !!h.$slots["right-sidebar"]
                })
              }, [
                h.$slots["left-sidebar"] ? (p(), I("div", or, [
                  G(h.$slots, "left-sidebar", Be(qe(ee)))
                ])) : A("", !0),
                (et = h.presetRanges) != null && et.length ? (p(), I("div", sr, [
                  (p(!0), I(ye, null, Ne(h.presetRanges, (J, at) => (p(), I("div", {
                    key: at,
                    style: ut(J.style || {}),
                    class: "dp__preset_range",
                    onClick: (fe) => M(Y)(J.range, !!J.slot)
                  }, [
                    J.slot ? G(h.$slots, J.slot, {
                      key: 0,
                      presetDateRange: M(Y),
                      label: J.label,
                      range: J.range
                    }) : (p(), I(ye, { key: 1 }, [
                      tt(Ye(J.label), 1)
                    ], 64))
                  ], 12, ur))), 128))
                ])) : A("", !0),
                ae("div", {
                  class: "dp__instance_calendar",
                  ref_key: "calendarWrapperRef",
                  ref: P,
                  role: "document"
                }, [
                  ae("div", {
                    class: ge(vt.value)
                  }, [
                    (p(!0), I(ye, null, Ne(oe.value, (J, at) => (p(), I("div", {
                      key: J,
                      class: ge(Bt.value)
                    }, [
                      !h.disableMonthYearSelect && !h.timePicker ? (p(), me(zl, Ce({
                        key: 0,
                        ref_for: !0,
                        ref: (fe) => {
                          fe && (k.value[at] = fe);
                        },
                        months: nt.value,
                        years: Je.value,
                        month: M(N)(J),
                        year: M(_)(J),
                        instance: J,
                        "internal-model-value": e.internalModelValue
                      }, s.value, {
                        onMount: W[0] || (W[0] = (fe) => Vt("monthYearInput")),
                        onResetFlow: V,
                        onUpdateMonthYear: (fe) => M(z)(J, fe),
                        onMonthYearSelect: M($),
                        onOverlayClosed: ue
                      }), Ue({ _: 2 }, [
                        Ne(M(Ze), (fe, ra) => ({
                          name: fe,
                          fn: ce((Xt) => [
                            G(h.$slots, fe, Be(qe(Xt)))
                          ])
                        }))
                      ]), 1040, ["months", "years", "month", "year", "instance", "internal-model-value", "onUpdateMonthYear", "onMonthYearSelect"])) : A("", !0),
                      kt(Ol, Ce({
                        ref_for: !0,
                        ref: (fe) => {
                          fe && (Q.value[at] = fe);
                        },
                        "specific-mode": Tt.value,
                        "get-week-num": M(u),
                        instance: J,
                        "mapped-dates": Gt.value(J),
                        month: M(N)(J),
                        year: M(_)(J)
                      }, s.value, {
                        onSelectDate: (fe) => M(f)(fe, !re.value(J)),
                        onHandleSpace: (fe) => Mn(fe, !re.value(J)),
                        onSetHoverDate: W[1] || (W[1] = (fe) => M(le)(fe)),
                        onHandleScroll: (fe) => M(l)(fe, J),
                        onHandleSwipe: (fe) => M(R)(fe, J),
                        onMount: W[2] || (W[2] = (fe) => Vt("calendar")),
                        onResetFlow: V,
                        onTooltipOpen: W[3] || (W[3] = (fe) => h.$emit("tooltip-open", fe)),
                        onTooltipClose: W[4] || (W[4] = (fe) => h.$emit("tooltip-close", fe))
                      }), Ue({ _: 2 }, [
                        Ne(M(We), (fe, ra) => ({
                          name: fe,
                          fn: ce((Xt) => [
                            G(h.$slots, fe, Be(qe({ ...Xt })))
                          ])
                        }))
                      ]), 1040, ["specific-mode", "get-week-num", "instance", "mapped-dates", "month", "year", "onSelectDate", "onHandleSpace", "onHandleScroll", "onHandleSwipe"])
                    ], 2))), 128))
                  ], 2),
                  ae("div", null, [
                    h.$slots["time-picker"] ? G(h.$slots, "time-picker", Be(Ce({ key: 0 }, { time: M(w), updateTime: M(y) }))) : (p(), I(ye, { key: 1 }, [
                      h.enableTimePicker && !h.monthPicker && !h.weekPicker ? (p(), me(ar, Ce({
                        key: 0,
                        ref_key: "timePickerRef",
                        ref: j,
                        hours: M(w).hours,
                        minutes: M(w).minutes,
                        seconds: M(w).seconds,
                        "internal-model-value": e.internalModelValue
                      }, s.value, {
                        onMount: W[5] || (W[5] = (J) => Vt("timePicker")),
                        "onUpdate:hours": W[6] || (W[6] = (J) => M(y)(J)),
                        "onUpdate:minutes": W[7] || (W[7] = (J) => M(y)(J, !1)),
                        "onUpdate:seconds": W[8] || (W[8] = (J) => M(y)(J, !1, !0)),
                        onResetFlow: V,
                        onOverlayClosed: De,
                        onOverlayOpened: W[9] || (W[9] = (J) => h.$emit("time-picker-open", J)),
                        onAmPmChange: W[10] || (W[10] = (J) => h.$emit("am-pm-change", J))
                      }), Ue({ _: 2 }, [
                        Ne(M(Re), (J, at) => ({
                          name: J,
                          fn: ce((fe) => [
                            G(h.$slots, J, Be(qe(fe)))
                          ])
                        }))
                      ]), 1040, ["hours", "minutes", "seconds", "internal-model-value"])) : A("", !0)
                    ], 64))
                  ])
                ], 512),
                h.$slots["right-sidebar"] ? (p(), I("div", ir, [
                  G(h.$slots, "right-sidebar", Be(qe(ee)))
                ])) : A("", !0),
                h.$slots["action-extra"] ? (p(), I("div", dr, [
                  h.$slots["action-extra"] ? G(h.$slots, "action-extra", {
                    key: 0,
                    selectCurrentDate: M(r)
                  }) : A("", !0)
                ])) : A("", !0)
              ], 2),
              !h.autoApply || h.keepActionRow ? (p(), me(Ml, Ce({
                key: 2,
                "menu-mount": U.value,
                "calendar-width": B.value,
                "internal-model-value": e.internalModelValue
              }, s.value, {
                onClosePicker: W[11] || (W[11] = (J) => h.$emit("close-picker")),
                onSelectDate: W[12] || (W[12] = (J) => h.$emit("select-date")),
                onInvalidSelect: W[13] || (W[13] = (J) => h.$emit("invalid-select")),
                onSelectNow: M(r)
              }), Ue({ _: 2 }, [
                Ne(M(Ie), (J, at) => ({
                  name: J,
                  fn: ce((fe) => [
                    G(h.$slots, J, Be(qe({ ...fe })))
                  ])
                }))
              ]), 1040, ["menu-mount", "calendar-width", "internal-model-value", "onSelectNow"])) : A("", !0)
            ], 42, rr)
          ];
        }),
        _: 3
      }, 8, ["name", "css"]);
    };
  }
}), fr = typeof window < "u" ? window : void 0, un = () => {
}, vr = (e) => sa() ? (ua(e), !0) : !1, mr = (e, n, a, t) => {
  if (!e)
    return un;
  let s = un;
  const m = dt(
    () => M(e),
    (C) => {
      s(), C && (C.addEventListener(n, a, t), s = () => {
        C.removeEventListener(n, a, t), s = un;
      });
    },
    { immediate: !0, flush: "post" }
  ), g = () => {
    m(), s();
  };
  return vr(g), g;
}, yr = (e, n, a, t = {}) => {
  const { window: s = fr, event: m = "pointerdown" } = t;
  return s ? mr(s, m, (C) => {
    const E = Te(e), S = Te(n);
    !E || !S || E === C.target || C.composedPath().includes(E) || C.composedPath().includes(S) || a(C);
  }, { passive: !0 }) : void 0;
}, gr = /* @__PURE__ */ Xe({
  __name: "VueDatePicker",
  props: {
    ...ft
  },
  emits: [
    "update:model-value",
    "text-submit",
    "closed",
    "cleared",
    "open",
    "focus",
    "blur",
    "internal-model-change",
    "recalculate-position",
    "flow-step",
    "update-month-year",
    "invalid-select",
    "invalid-fixed-range",
    "tooltip-open",
    "tooltip-close",
    "time-picker-open",
    "time-picker-close",
    "am-pm-change",
    "range-start",
    "range-end"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, s = pn(), m = H(!1), g = Rt(t, "modelValue"), C = Rt(t, "timezone"), E = H(null), S = H(null), F = H(!1), P = H(null), c = $t({
      disabledDates: null,
      allowedDates: null,
      highlightedDates: null
    }), { setMenuFocused: k, setShiftKey: Q } = Qn(), { clearArrowNav: j } = ct(), { validateDate: x, isValidTime: B, defaults: U, mapDatesArrToMap: O } = xe(t);
    Ge(() => {
      N(t.modelValue), t.inline || (V(P.value).addEventListener("scroll", $), window.addEventListener("resize", l)), t.inline && (m.value = !0), O(c);
    }), hn(() => {
      if (!t.inline) {
        const Z = V(P.value);
        Z && Z.removeEventListener("scroll", $), window.removeEventListener("resize", l);
      }
    });
    const q = pt(s, "all", t.presetRanges), K = pt(s, "input");
    dt(
      [g, C],
      () => {
        N(g.value);
      },
      { deep: !0 }
    );
    const { openOnTop: ne, menuStyle: se, resetPosition: de, setMenuPosition: ue, setInitialPosition: ve, getScrollableParent: V } = vl(E, S, a, t), {
      inputValue: D,
      internalModelValue: d,
      parseExternalModelValue: N,
      emitModelValue: _,
      formatInputValue: w,
      checkBeforeEmit: y
    } = cl(a, t, F), z = L(
      () => ({
        dp__main: !0,
        dp__theme_dark: t.dark,
        dp__theme_light: !t.dark,
        dp__flex_display: t.inline,
        dp__flex_display_with_input: t.inlineWithInput
      })
    ), f = L(() => t.dark ? "dp__theme_dark" : "dp__theme_light"), u = L(() => t.teleport ? {
      to: typeof t.teleport == "boolean" ? "body" : t.teleport,
      disabled: t.inline
    } : { class: "dp__outer_menu_wrap" }), $ = () => {
      m.value && (t.closeOnScroll ? be() : ue());
    }, l = () => {
      m.value && ue();
    }, v = async () => {
      var Z, oe, re;
      !t.disabled && !t.readonly && (de(), await ot(), m.value = !0, await ot(), ve(), await ot(), ue(), delete se.value.opacity, (Z = U.value.transitions) != null && Z.menuAppear || (re = (oe = E.value) == null ? void 0 : oe.$el) == null || re.classList.add("dp__menu_transitioned"), m.value && a("open"), m.value || Se(), N(t.modelValue));
    }, R = () => {
      D.value = "", Se(), a("update:model-value", null), a("cleared"), t.closeOnClearValue && be();
    }, i = () => {
      const Z = d.value;
      return !Z || !Array.isArray(Z) && x(Z) ? !0 : Array.isArray(Z) ? Z.length === 2 && x(Z[0]) && x(Z[1]) ? !0 : x(Z[0]) : !1;
    }, r = () => {
      y() && i() ? (_(), be()) : a("invalid-select", d.value);
    }, Y = (Z) => {
      le(), _(), t.closeOnAutoApply && !Z && be();
    }, le = () => {
      S.value && t.textInput && S.value.setParsedDate(d.value);
    }, Ae = (Z = !1) => {
      t.autoApply && B(d.value) && i() && (t.range && Array.isArray(d.value) ? (t.partialRange || d.value.length === 2) && Y(Z) : Y(Z));
    }, Se = () => {
      t.textInput || (d.value = null);
    }, be = () => {
      t.inline || (m.value && (m.value = !1, k(!1), Q(!1), j(), a("closed"), ve(), D.value && N(g.value)), Se());
    }, ee = (Z, oe) => {
      if (!Z) {
        d.value = null;
        return;
      }
      d.value = Z, oe && (r(), a("text-submit"));
    }, We = () => {
      t.autoApply && B(d.value) && _(), le();
    }, Ie = () => m.value ? be() : v(), Re = (Z) => {
      d.value = Z;
    }, Ze = () => {
      t.textInput && (F.value = !0, w()), a("focus");
    }, wt = () => {
      t.textInput && (F.value = !1, N(t.modelValue)), a("blur");
    }, Je = (Z) => {
      E.value && E.value.updateMonthYear(0, {
        month: Ln(Z.month),
        year: Ln(Z.year)
      });
    }, nt = (Z) => {
      N(Z || t.modelValue);
    }, ze = (Z, oe) => {
      var re;
      (re = E.value) == null || re.switchView(Z, oe);
    };
    return yr(
      E,
      S,
      t.onClickOutside ? () => t.onClickOutside(i) : be
    ), n({
      closeMenu: be,
      selectDate: r,
      clearValue: R,
      openMenu: v,
      onScroll: $,
      formatInputValue: w,
      // exposed for testing purposes
      updateInternalModelValue: Re,
      // modify internal modelValue
      setMonthYear: Je,
      parseModel: nt,
      switchView: ze
    }), (Z, oe) => (p(), I("div", {
      class: ge(z.value),
      ref_key: "pickerWrapperRef",
      ref: P
    }, [
      kt(wl, Ce({
        ref_key: "inputRef",
        ref: S,
        "is-menu-open": m.value,
        "input-value": M(D),
        "onUpdate:inputValue": oe[0] || (oe[0] = (re) => Tn(D) ? D.value = re : null)
      }, Z.$props, {
        onClear: R,
        onOpen: v,
        onSetInputDate: ee,
        onSetEmptyDate: M(_),
        onSelectDate: r,
        onToggle: Ie,
        onClose: be,
        onFocus: Ze,
        onBlur: wt,
        onRealBlur: oe[1] || (oe[1] = (re) => F.value = !1)
      }), Ue({ _: 2 }, [
        Ne(M(K), (re, Tt) => ({
          name: re,
          fn: ce((vt) => [
            G(Z.$slots, re, Be(qe(vt)))
          ])
        }))
      ]), 1040, ["is-menu-open", "input-value", "onSetEmptyDate"]),
      m.value ? (p(), me(xn(Z.teleport ? ia : "div"), Be(Ce({ key: 0 }, u.value)), {
        default: ce(() => [
          m.value ? (p(), me(cr, Ce({
            key: 0,
            ref_key: "dpMenuRef",
            ref: E,
            class: f.value,
            style: Z.inline ? void 0 : M(se),
            "open-on-top": M(ne),
            "arr-map-values": c
          }, Z.$props, {
            "internal-model-value": M(d),
            "onUpdate:internalModelValue": oe[2] || (oe[2] = (re) => Tn(d) ? d.value = re : null),
            onClosePicker: be,
            onSelectDate: r,
            onAutoApply: Ae,
            onTimeUpdate: We,
            onFlowStep: oe[3] || (oe[3] = (re) => Z.$emit("flow-step", re)),
            onUpdateMonthYear: oe[4] || (oe[4] = (re) => Z.$emit("update-month-year", re)),
            onInvalidSelect: oe[5] || (oe[5] = (re) => Z.$emit("invalid-select", M(d))),
            onInvalidFixedRange: oe[6] || (oe[6] = (re) => Z.$emit("invalid-fixed-range", re)),
            onRecalculatePosition: M(ue),
            onTooltipOpen: oe[7] || (oe[7] = (re) => Z.$emit("tooltip-open", re)),
            onTooltipClose: oe[8] || (oe[8] = (re) => Z.$emit("tooltip-close", re)),
            onTimePickerOpen: oe[9] || (oe[9] = (re) => Z.$emit("time-picker-open", re)),
            onTimePickerClose: oe[10] || (oe[10] = (re) => Z.$emit("time-picker-close", re)),
            onAmPmChange: oe[11] || (oe[11] = (re) => Z.$emit("am-pm-change", re)),
            onRangeStart: oe[12] || (oe[12] = (re) => Z.$emit("range-start", re)),
            onRangeEnd: oe[13] || (oe[13] = (re) => Z.$emit("range-end", re))
          }), Ue({ _: 2 }, [
            Ne(M(q), (re, Tt) => ({
              name: re,
              fn: ce((vt) => [
                G(Z.$slots, re, Be(qe({ ...vt })))
              ])
            }))
          ]), 1040, ["class", "style", "open-on-top", "arr-map-values", "internal-model-value", "onRecalculatePosition"])) : A("", !0)
        ]),
        _: 3
      }, 16)) : A("", !0)
    ], 2));
  }
}), la = /* @__PURE__ */ (() => {
  const e = gr;
  return e.install = (n) => {
    n.component("Vue3DatePicker", e);
  }, e;
})(), hr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: la
}, Symbol.toStringTag, { value: "Module" }));
Object.entries(hr).forEach(([e, n]) => {
  e !== "default" && (la[e] = n);
});
export {
  la as default
};
