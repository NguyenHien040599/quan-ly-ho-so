import {
  VCheckboxBtn,
  makeFilterProps,
  makeSelectProps,
  useFilter
} from "./chunk-J46C4SSU.js";
import {
  VTextField,
  filterVTextFieldProps,
  makeVTextFieldProps
} from "./chunk-P3ISA4LD.js";
import "./chunk-5TOHGLTY.js";
import {
  useForm
} from "./chunk-GI2JUJJC.js";
import {
  VList,
  VListItem,
  useItems
} from "./chunk-NYSIELGY.js";
import {
  VChip
} from "./chunk-KCLEPWNS.js";
import "./chunk-OTPD6P5Q.js";
import "./chunk-DO4AMFBT.js";
import {
  VMenu
} from "./chunk-OKX2N256.js";
import "./chunk-C6OTZ2XA.js";
import "./chunk-BX2QN7BW.js";
import {
  forwardRefs
} from "./chunk-GFCECH5Z.js";
import "./chunk-XSJMIFYO.js";
import {
  makeTransitionProps
} from "./chunk-72LU4UEZ.js";
import "./chunk-Z2JTOSYC.js";
import "./chunk-64PMG2DF.js";
import "./chunk-2T5KXMNO.js";
import "./chunk-DJGCMMNL.js";
import "./chunk-RPF7XF6G.js";
import "./chunk-FG2MS5DW.js";
import "./chunk-CWRX27OS.js";
import "./chunk-EF5NPB23.js";
import {
  VDefaultsProvider
} from "./chunk-YDHVWZNB.js";
import "./chunk-WUTR3YAI.js";
import "./chunk-4YNTCYST.js";
import "./chunk-IGV3C7YQ.js";
import "./chunk-DIUFMP6Z.js";
import {
  useLocale
} from "./chunk-YRSM2AG3.js";
import {
  useProxiedModel
} from "./chunk-FZDB5NGM.js";
import "./chunk-SBSUWAID.js";
import "./chunk-5TXAXXTZ.js";
import "./chunk-RN6QXMPV.js";
import "./chunk-QKD4SKS3.js";
import "./chunk-LOTHVIFN.js";
import "./chunk-RYRXHHBD.js";
import "./chunk-3NLU6K6P.js";
import "./chunk-XDPPJHDK.js";
import {
  genericComponent,
  omit,
  useRender,
  wrapInArray
} from "./chunk-Q3V67DEH.js";
import {
  Fragment,
  computed,
  createTextVNode,
  createVNode,
  mergeProps,
  nextTick,
  ref,
  watch
} from "./chunk-3NMN3MUW.js";
import "./chunk-RSJERJUL.js";

// node_modules/vuetify/lib/components/VAutocomplete/VAutocomplete.mjs
import "D:/workspace/quan-ly-ho-so/node_modules/vuetify/lib/components/VAutocomplete/VAutocomplete.css";
function highlightResult(text, matches, length) {
  if (matches == null)
    return text;
  if (Array.isArray(matches))
    throw new Error("Multiple matches is not implemented");
  return typeof matches === "number" && ~matches ? createVNode(Fragment, null, [createVNode("span", {
    "class": "v-autocomplete__unmask"
  }, [text.substr(0, matches)]), createVNode("span", {
    "class": "v-autocomplete__mask"
  }, [text.substr(matches, length)]), createVNode("span", {
    "class": "v-autocomplete__unmask"
  }, [text.substr(matches + length)])]) : text;
}
var VAutocomplete = genericComponent()({
  name: "VAutocomplete",
  props: {
    // TODO: implement post keyboard support
    // autoSelectFirst: Boolean,
    search: String,
    ...makeFilterProps({
      filterKeys: ["title"]
    }),
    ...makeSelectProps(),
    ...omit(makeVTextFieldProps({
      modelValue: null
    }), ["validationValue", "dirty", "appendInnerIcon"]),
    ...makeTransitionProps({
      transition: false
    })
  },
  emits: {
    "update:search": (val) => true,
    "update:modelValue": (val) => true,
    "update:menu": (val) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const vTextFieldRef = ref();
    const isFocused = ref(false);
    const isPristine = ref(true);
    const vMenuRef = ref();
    const _menu = useProxiedModel(props, "menu");
    const menu = computed({
      get: () => _menu.value,
      set: (v) => {
        var _a;
        if (_menu.value && !v && ((_a = vMenuRef.value) == null ? void 0 : _a.Î¨openChildren))
          return;
        _menu.value = v;
      }
    });
    const {
      items,
      transformIn,
      transformOut
    } = useItems(props);
    const search = useProxiedModel(props, "search", "");
    const model = useProxiedModel(props, "modelValue", [], (v) => transformIn(wrapInArray(v)), (v) => {
      const transformed = transformOut(v);
      return props.multiple ? transformed : transformed[0] ?? null;
    });
    const form = useForm();
    const {
      filteredItems,
      getMatches
    } = useFilter(props, items, computed(() => isPristine.value ? void 0 : search.value));
    const selections = computed(() => {
      return model.value.map((v) => {
        return items.value.find((item) => props.valueComparator(item.value, v.value)) || v;
      });
    });
    const displayItems = computed(() => {
      if (props.hideSelected) {
        return filteredItems.value.filter((filteredItem) => !selections.value.some((s) => s.value === filteredItem.value));
      }
      return filteredItems.value;
    });
    const selected = computed(() => selections.value.map((selection) => selection.props.value));
    const listRef = ref();
    function onClear(e) {
      if (props.openOnClear) {
        menu.value = true;
      }
      search.value = "";
    }
    function onMousedownControl() {
      if (props.hideNoData && !items.value.length || props.readonly || (form == null ? void 0 : form.isReadonly.value))
        return;
      menu.value = true;
    }
    function onKeydown(e) {
      var _a, _b;
      if (props.readonly || (form == null ? void 0 : form.isReadonly.value))
        return;
      if (["Enter", "ArrowDown", "ArrowUp"].includes(e.key)) {
        e.preventDefault();
      }
      if (["Enter", "ArrowDown"].includes(e.key)) {
        menu.value = true;
      }
      if (["Escape"].includes(e.key)) {
        menu.value = false;
      }
      if (["Enter", "Escape", "Tab"].includes(e.key)) {
        isPristine.value = true;
      }
      if (e.key === "ArrowDown") {
        (_a = listRef.value) == null ? void 0 : _a.focus("next");
      } else if (e.key === "ArrowUp") {
        (_b = listRef.value) == null ? void 0 : _b.focus("prev");
      }
    }
    function onInput(e) {
      search.value = e.target.value;
    }
    function onAfterLeave() {
      if (isFocused.value)
        isPristine.value = true;
    }
    function onFocusin(e) {
      isFocused.value = true;
    }
    function onFocusout(e) {
      var _a;
      if (e.relatedTarget == null) {
        (_a = vTextFieldRef.value) == null ? void 0 : _a.focus();
      }
    }
    const isSelecting = ref(false);
    function select(item) {
      if (props.multiple) {
        const index = selected.value.findIndex((selection) => props.valueComparator(selection, item.value));
        if (index === -1) {
          model.value = [...model.value, item];
          search.value = "";
        } else {
          const value = [...model.value];
          value.splice(index, 1);
          model.value = value;
        }
      } else {
        model.value = [item];
        isSelecting.value = true;
        if (!slots.selection) {
          search.value = item.title;
        }
        menu.value = false;
        isPristine.value = true;
        nextTick(() => isSelecting.value = false);
      }
    }
    watch(isFocused, (val) => {
      var _a;
      if (val) {
        isSelecting.value = true;
        search.value = props.multiple || !!slots.selection ? "" : String(((_a = selections.value.at(-1)) == null ? void 0 : _a.props.title) ?? "");
        isPristine.value = true;
        nextTick(() => isSelecting.value = false);
      } else {
        menu.value = false;
        search.value = "";
      }
    });
    watch(search, (val) => {
      if (!isFocused.value || isSelecting.value)
        return;
      if (val)
        menu.value = true;
      isPristine.value = !val;
    });
    useRender(() => {
      const hasChips = !!(props.chips || slots.chip);
      const hasList = !!(!props.hideNoData || displayItems.value.length || slots.prepend || slots.append || slots["no-data"]);
      const [textFieldProps] = filterVTextFieldProps(props);
      return createVNode(VTextField, mergeProps({
        "ref": vTextFieldRef
      }, textFieldProps, {
        "modelValue": search.value,
        "onUpdate:modelValue": (v) => {
          if (v == null)
            model.value = [];
        },
        "validationValue": model.externalValue,
        "dirty": model.value.length > 0,
        "onInput": onInput,
        "class": ["v-autocomplete", {
          "v-autocomplete--active-menu": menu.value,
          "v-autocomplete--chips": !!props.chips,
          [`v-autocomplete--${props.multiple ? "multiple" : "single"}`]: true,
          "v-autocomplete--selection-slot": !!slots.selection
        }],
        "appendInnerIcon": props.menuIcon,
        "readonly": props.readonly,
        "onClick:clear": onClear,
        "onMousedown:control": onMousedownControl,
        "onFocus": () => isFocused.value = true,
        "onBlur": () => isFocused.value = false,
        "onKeydown": onKeydown
      }), {
        ...slots,
        default: () => createVNode(Fragment, null, [createVNode(VMenu, mergeProps({
          "ref": vMenuRef,
          "modelValue": menu.value,
          "onUpdate:modelValue": ($event) => menu.value = $event,
          "activator": "parent",
          "contentClass": "v-autocomplete__content",
          "eager": props.eager,
          "maxHeight": 310,
          "openOnClick": false,
          "closeOnContentClick": false,
          "transition": props.transition,
          "onAfterLeave": onAfterLeave
        }, props.menuProps), {
          default: () => [hasList && createVNode(VList, {
            "ref": listRef,
            "selected": selected.value,
            "selectStrategy": props.multiple ? "independent" : "single-independent",
            "onMousedown": (e) => e.preventDefault(),
            "onFocusin": onFocusin,
            "onFocusout": onFocusout
          }, {
            default: () => {
              var _a, _b, _c;
              return [!displayItems.value.length && !props.hideNoData && (((_a = slots["no-data"]) == null ? void 0 : _a.call(slots)) ?? createVNode(VListItem, {
                "title": t(props.noDataText)
              }, null)), (_b = slots["prepend-item"]) == null ? void 0 : _b.call(slots), displayItems.value.map((item, index) => {
                var _a2;
                return ((_a2 = slots.item) == null ? void 0 : _a2.call(slots, {
                  item,
                  index,
                  props: mergeProps(item.props, {
                    onClick: () => select(item)
                  })
                })) ?? createVNode(VListItem, mergeProps({
                  "key": index
                }, item.props, {
                  "onClick": () => select(item)
                }), {
                  prepend: (_ref2) => {
                    let {
                      isSelected
                    } = _ref2;
                    return props.multiple && !props.hideSelected ? createVNode(VCheckboxBtn, {
                      "modelValue": isSelected,
                      "ripple": false
                    }, null) : void 0;
                  },
                  title: () => {
                    var _a3, _b2;
                    return isPristine.value ? item.title : highlightResult(item.title, (_a3 = getMatches(item)) == null ? void 0 : _a3.title, ((_b2 = search.value) == null ? void 0 : _b2.length) ?? 0);
                  }
                });
              }), (_c = slots["append-item"]) == null ? void 0 : _c.call(slots)];
            }
          })]
        }), selections.value.map((item, index) => {
          function onChipClose(e) {
            e.stopPropagation();
            e.preventDefault();
            select(item);
          }
          const slotProps = {
            "onClick:close": onChipClose,
            modelValue: true,
            "onUpdate:modelValue": void 0
          };
          return createVNode("div", {
            "key": item.value,
            "class": "v-autocomplete__selection"
          }, [hasChips ? createVNode(VDefaultsProvider, {
            "defaults": {
              VChip: {
                closable: props.closableChips,
                size: "small",
                text: item.title
              }
            }
          }, {
            default: () => [slots.chip ? slots.chip({
              item,
              index,
              props: slotProps
            }) : createVNode(VChip, slotProps, null)]
          }) : slots.selection ? slots.selection({
            item,
            index
          }) : createVNode("span", {
            "class": "v-autocomplete__selection-text"
          }, [item.title, props.multiple && index < selections.value.length - 1 && createVNode("span", {
            "class": "v-autocomplete__selection-comma"
          }, [createTextVNode(",")])])]);
        })])
      });
    });
    return forwardRefs({
      isFocused,
      isPristine,
      menu,
      search,
      filteredItems,
      select
    }, vTextFieldRef);
  }
});
export {
  VAutocomplete
};
//# sourceMappingURL=vuetify_lib_components_VAutocomplete_index__mjs.js.map
